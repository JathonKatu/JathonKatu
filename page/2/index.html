<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>You&#39;s Tab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Only talented people are qualified to say their dreams">
<meta property="og:type" content="website">
<meta property="og:title" content="You&#39;s Tab">
<meta property="og:url" content="https://jathonkatu.github.io/page/2/index.html">
<meta property="og:site_name" content="You&#39;s Tab">
<meta property="og:description" content="Only talented people are qualified to say their dreams">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="You&#39;s Tab">
<meta name="twitter:description" content="Only talented people are qualified to say their dreams">
  
    <link rel="alternate" href="/atom.xml" title="You&#39;s Tab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">You&#39;s Tab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hobby and Life</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jathonkatu.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-入侵检测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/入侵检测/" class="article-date">
  <time datetime="2018-01-16T10:11:25.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/毕设/">毕设</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/入侵检测/">入侵检测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>什么是入侵检测<br>   入侵检测(Intrusion Detection )是对入侵行为的检测。它通过收集和分析计算机网络或计算机系统中若于关键点的信息，检查网络或系统中是否存在违反安全策略的行为和被攻击的迹象。入侵检测作为一种积极主动的安全防护技术，提供了对内部攻击、外部攻击和误操作的实时保护，在网络系统受到危害之前拦截和响应入侵入侵检测技术虽然也能够对网络攻击进行识另拼作出反应，但其侧重点还是在于发现，而不能代替防火墙系统执行整个网络的访问控制策略。<br>     入侵检测系统（intrusion Detection System ,IDS）是对计算机和网络资源的恶意使用为进行识别的系统；它的目的是监测和发现可能存在的攻击行为，包括来自系统外部的入侵行为和来自内部用户的非授权行为，并且采取相应的防护手段。</p>
<p>入侵检测系统的分类</p>
<p>一：按检测分析方法分类</p>
<p>1：异常检测<br>   基于异常的入侵检测方法主要来源于这样的思想，任何人的正常行为都是有一定的规律的，并且可以通过分析这些行为的日志信息型总结出这些规律，而入侵和滥用行为规则通常和正常的行为存在严重的差异，通过检查这些差异就可以判断是否为入侵。总之，一场检测基于这样的假设和前提：用户活动是有规律的，而且这种规律是可以通过数据有效的描述和反映；入侵时异常活动的子集和用户的正常活动有着可以描述的明显的区别。<br>   异常监测系统首先经过一个学习阶段，总结正常的行为的轮廓成为自己的先验知识，系统运行时将信息采集子系统获得并预处理后的数据与正常行为模式比较，如果差异不超出预设阀值，则认为是正常的，出现较大差异即超过阀值则判定为入侵。<br>   <img src="/2018/01/16/入侵检测/../入侵检测/ruqinjiance1.png" alt="异常检测"></p>
<p>   异常检测系统有如下特点：<br>      1)：检测的效率取决于用户轮过的完备性和监控的频率，因为不需要对每种入侵行为进行定义，而能有效检测未知的入侵，因此也称为一个研究热点<br>      2)：系统能针对用户行为的改变进行自我调整和优化，但随着检测模型的逐步精确，异常检测会消耗更多的系统资源</p>
<p>2：误用检测<br>   又称为基于特征的检测，基于误用的入侵检测系统通过使用某种模式或者信号标示表示攻击，进而发现同类型的攻击，其实现过程是：先收集非正常操作的行为特征，系统就认为这种行为是入侵，系统处理过程如同：<br>   <img src="/2018/01/16/入侵检测/../入侵检测/ruqinjiance2.png" alt="误用检测"></p>
<p>这里写图片描述<br>   这种方法可以检测到许多甚至是全部已知的攻击行为，如果入侵特征与正常的用户行为能匹配，则系统会发生误报，如果没有特征能与某种新的攻击行为匹配，则系统会发生漏报。<br>   特点：采用特征匹配模式能明显降低错报率，但漏报率随之增加，攻击特征的细微变化，会使得滥用检测无能为力。</p>
<p>二：按数据源分为</p>
<p>1：基于主机的入侵检测<br>   基于主机的入侵检测是入侵检测的最初期形式，这种入侵检测系统通常运行在被检测的主机或者服务器上，实时检测检测系统的运行，通常从主机的审计记录和日志文件中获得所需的主要数据源，并辅之以主机上的其他信息，在此基础上完成检测攻击行为的任务。特别的，从主机入侵检测技术中还可以单独分离出基于应用的入侵检测模型，这是特别针对于某个特定任务的应用程序而设计的入侵检测技术，采用的输入数据源是应用程序的日志信息。<br>   基于主机的入侵检测悉尼型来源主要包括：<br>      1）：系统信息，几乎所有的操作系统都提供一组命令，获得本机当前激活的进程的状态信息，他们直接检查内核程序的内存信息。<br>      2）：记账，通常指由操作系统或操作员所执行的特定操作，记录计算机资源的使用情况，例如CPU占用时间，内存，硬盘，网络使用情况。在计算机未普及之前，记账是为了向用户收费的。<br>       3）：系统日志，可分为操作系统日志和应用程序日志两部分。操作系统日志从不同方面记录了系统中发生的事情，对于入侵检测而言，具备重要的价值，当一个进程终止时，系统内核为每个进程在进程日志文件中写入一条记录。<br>       4）：C2安全审计，记录所有可能与安全性有关的发生在系统上的事情。</p>
<p>   基于主机的入侵检测能够较为准确的检测到发生在主机系统高层的复杂攻击行为，其中，许多发生在应用进程级别的攻击行为是无法依靠基于网络的入侵检测来完成的，基于主机的入侵检测系统巨头检测效率高，分析代价小，分析速度快的特点，能够迅速并准确的定为入侵者，并可以结合操作系统和应用程序的行为特征对入侵进行进一步的分析，响应。比如，一旦检测到有入侵行为，我们可以立即使该用户的账号失效，用户的进程中断。他可以帮助发现基于网络的入侵检测无法检测的加密攻击。基于主机的入侵检测系统尤其对于独立的服务器及应用构造简单，易于理解，也只有这种检测方式能检测出通过控制台的入侵活动。目前许多是基于主机日志分析的。</p>
<p>   同时，基于主机的入侵检测系统也有若干显而易见的缺点，由于他一定程度上依赖于特定的操作系统平台，管理困难，必须按照每一台机器的环境配置管理。同时主机的日志提供的信息有限，有的入侵手段和途径不会在日志中有所反映，日志系统对网络层的入侵行为无能为力。在数据提取的实时性，充分性，可靠性方面基于主机日志的入侵检测系统不如基于网络的入侵检测系统。他通常无法对网络环境下发生的大量攻击行为作出及时的反应，他在所保护主机上运行，这也会影响宿主机的运行性能。</p>
<p>2：基于网络的入侵检测系统<br>   通过监听网络中的数据包，既抓包技术来获取必要的数据来源，并通过协议分析，特征匹配，统计分析等手段当前发生的攻击行为。<br>   基于网络的入侵检测的优点是：一个安装在网络合适位置NIDS系统可以监视一个很大范围的网络，他的运行丝毫不影响主机或者服务器的运行效率，因为基于网络的入侵检测系统通常采取独立主机和被动监听的工作模式，他对网络的性能影响也很小。NIDS能够实时监控网络中的数据流量，并发现潜在的攻击行为和作为迅速的响应，而使攻击者难以发现自己已被监视，另外，他的分析对象是网络协议，一般没有移植性的问题。<br>   同事基于网络的入侵检测系统的主要问题是监视数据量过于庞大并且他不结合操作系统特征来对网络行为进行准确的判断，在网络通讯的高峰时刻，难以检查所有数据包；如果网络数据被加密，NIDS就不能扫描协议或内容NIDS不能判断一个攻击是否已经成功，对于渐进式，合作式的攻击难以防范。</p>
<p>常用的入侵检测技术</p>
<p>1：基于统计分析技术的入侵检测<br>   他试图建立一个对应”正常活动”的特征原型，然后把与所建立的特征原型中差别”很大”的所有行为都标志为异常。显而易见，当入侵集合与异常活动集合不完全相等时，一定会存在漏 报或者误报的问题，为了使漏报和误报的概率较为符合实际需要，必须选择一个区分异常事件的阀值，而调整和更新某些系统特征度量值的方法非常复杂，开销巨大，在实际情况下，试图用逻辑方法明确划分正常行为和异常行为两个集合非常困难，统计手段的主要优点是可以自适应学习用户的行为，主要问题是其可能被入侵者逐渐训练以致最终将入侵事件误认为是正常，并且阀值设置不会当导致大比例的误报与漏报，此外，由于统计量度对事件顺序的不敏感性，事件间的关系会漏掉。</p>
<p>2：基于模式预测异常检测<br>   基于模式预测异常检测方法的假设条件是：事件序列不是随机的，而是遵循可辨别的模式，这种检测方法的特点是考虑了事件的序列和相互关系。而基于时间的推理方法则利用时间规则识别用户行为正常模式的特征，通过归纳学习产生这些规则集，能动态的修改系统中的规则，使之具有高的预测性，准确性和可信度。如果规则大部分时间是正确的，并能够成功的运用预测所观察到的数据，那么规则就具有高的可信度，根据观察到用户的行为，归纳产生出一套规则集来构建用户的轮廓框架，如果观测到的事件序列匹配规则的左边，而后续事件显著的背离根据规则预测到的事件，那么系统就可以检测出这种偏离，这就表明用户操作是异常。如果能预测出不着呢刚才的后继事件的片段，则一定程度上断定用户行为的异常性，这种方法的主要优点是：<br>       1）：能较好地处理变化多样的用户行为，具有很强的时序模式。<br>       2）：能够集中考察少数几个相关的安全事件，而不是关注可疑的整个登录会话过程<br>       3）：对发现检测系统遭受攻击，具有良好的灵敏度，因为根据规则的蕴含语义，在系统学习阶段，能够更容易的辨别出欺骗者训练系统的企图<br>       预测模式生成技术的问题在于未被这些规则描述的入侵会被漏检</p>
<p>3：基于神经网络技术的入侵检测<br>   神经网络用给定的n个动作训练神经网络去预测用户的下一步行为。训练结束之后，神经网络使用已出现在网中的用户特征匹配实际的用户行为，标志统计差异较大的事件为异常或者非法。使用神经网络的优点是可以很好的处理噪声数据，因为他只与用户行为相关，而不依赖于任何底层数据特性的统计，但同样有入侵者能够在其徐诶阶段训练网络的问题。</p>
<p>4：基于机器学习异常检测<br>   这种异常检测方法通过机器学习实现入侵检测，其主要的方法有死记硬背式、监督、学习、归纳学习、类比学习等。</p>
<p>5：基于数据挖掘异常检测<br>   数据挖掘，也称知识发现，通常记录系统运行日志得数据库都非常大，如何从大量数据中“浓缩”出一个值或者一组值来表示对象得概貌，并以此进行行为的异常分析和检测，这就是数据挖掘技术在入侵检测系统的应用，数据挖掘中一般会用到数据聚类技术。</p>
<p>6：专家系统<br>   用专家系统对入侵进行检测，经常时针对具有明显特征的入侵行为，即所谓的规则，即时知识，专家系统的建立依赖于知识库的完备性，知识库的完备性又取决于审计记录的完备性和实时性。<br>       基于专家系统无用入侵检测方法是通过将安全专家的知识表示城IF-THEN规则形成专家知识库，然后，运用推理算法进行入侵检测，编码规则说明攻击的必需条件作为IF的组成部分，当规则的左边的全部条件都满足时，规则的右边的动作才会执行，入侵检测专家系统应用的实际问题时要处理大量的数据和依赖于审计跟踪的次序，其推理方式主要又以下两种：<br>       1)：根据给定的数据，应用符号推理出入侵的发生情况，需要解决的主要问题时处理序列数据和知识库的维护，不足之处就是只能检测已知。<br>       2)：根绝其他的入侵证据，进行不确定性推理，这种推理的局限性就是推理证据的不精确和专家知识的不精确。</p>
<p>入侵检测的技术关键<br>   入侵检测技术对于网络安全方面来说是一项重要的技术而提高入侵检查的一项根本方法就是提高模式匹配效率，提高模式匹配的效率也就是等于提升了网络安全。</p>
<p>一：模式匹配技术</p>
<p>1：模式匹配<br>   入侵检测系统对重要的网段进行监控，对网段中没个数据包进行模式匹配和分析。如果数据包内容和入侵检测系统规律相符，就会发出警报，并切断网络，由此可见模式匹配是影响入侵检测的关键技术。<br>       模式匹配定义为：设有给定的连哥哥串T和P，则在T中寻找P的子串的经过成为模式匹配。T称为正文，P称为模式，通常T的长度远远大于P的长度，若在T中找到等于P的子串，则匹配成功，否则匹配失败。</p>
<p>2：模式匹配的原理<br>   在入侵检测中，模式匹配可以理解为：给定入侵规则库中的一个特定的模式字符串P，在网络数据包T中进行查找，确定P是否在T中出现。</p>
<p>3：模式匹配的规则<br>   网络入侵检测以网络中采集的数据包为数据源，使用模式匹配方法对数据包进行检测从而发现网络中可能存在的入侵事件，其中对数据包的检测就是要在网络数据包中检测是否存在可以代表入侵行为或者入侵企图的一些字符串，即查找出某些入侵规则中规则选项中所标识的字符串，由于规则数较多，模式匹配过程是入侵检测系统中时间小号最大的环节之一。如果没有高效的模式匹配算法作为保障，检测过程中就会产生超时溢出错误，此时为了保证正常工作状态，系统将主动的丢弃一些数据包，形成漏检。<br>       所以，一个好的高效的模式皮匹配算法对入侵检测效率的提升至关重要。</p>
<p>二：模式匹配算法</p>
<p>参考：<a href="http://dsqiu.iteye.com/blog/1700312" target="_blank" rel="noopener">http://dsqiu.iteye.com/blog/1700312</a></p>
<p>案例说明</p>
<p>1：介绍<br>   以企业入侵日志为例，假设攻击者要攻击某个企业，那么必需使用进入到该企业的网络，已知该企业的网络分为内部用户和访客，每次登陆都会产生一系列的日志，那么如何根据这些wlan的访问日志来进行登陆用户的异常行为检测呢？</p>
<p>2：分析<br>   根据访问日志，我们并不能确定使用网络的用户哪个是进行入侵的，即我们没有一个明确的结果来判断入侵者和非入侵者，那么这里我们可以采用的入侵检测技术便可以是：基于统计的入侵检测技术</p>
<p>3：实现<br>   首先我们可以对访问者进行比例划分，例如9：1，利用90%的数据进行构建用户肖像，统计分析出用户肖像数据，继而利用10%的数据进行数据测试，主要依据的便是90%数据构建的用户模型。统计处测试用户产生的异常值。并可以根据实际情况设置一个阀值，来判定是否是入侵用户。</p>
<p>   其次，如果我们能明确知道哪些是入侵者，即数据产生方已经积累了一定的入侵用户，那么我们可以针对入侵者的入侵手段进行建模，比如说，这些入侵者都喜欢在凌晨3点，进行网络认证，且他们在线的时间较短，那么我们便可以收集这两个特征作为入侵者的特征，继而针对网络认证用户进行判断。</p>
<p>   当然我们也可以结合其他的一些辅助手段进行异常用户的检测，比如说黑名单，可以根据入侵者的行为模式构建哥规则列表，即符合该规则库中的任意一条规则几位入侵者。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/01/16/入侵检测/" data-id="cjesiknpk000qq474oot1lro6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/入侵检测/">入侵检测</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA_GC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/JAVA_GC/" class="article-date">
  <time datetime="2018-01-16T07:10:22.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/JAVA_GC/">Java_GC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。<br>程序员可以调用System.gc()和Runtime.gc()来请求JVM启动垃圾回收，但是JVM并不保证这些请求都会执行，启动时间依然取决于堆内存中的Eden区是否可用。</p>
<p>在运行时，Java的实例被存放在堆内存区域。当一个对象不再被引用时，满足条件就会从堆内存移除。在垃圾回收进程中，这些对象将会从堆内存移除并且内存空间被回收。堆内存以下三个主要区域：  </p>
<h3 id="新生代（Young-Generation）-Eden-s0-s1"><a href="#新生代（Young-Generation）-Eden-s0-s1" class="headerlink" title="新生代（Young Generation）(Eden-s0-s1)"></a>新生代（Young Generation）(Eden-s0-s1)</h3><h5 id="Eden空间（Eden-space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的-Eden-区中。"><a href="#Eden空间（Eden-space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的-Eden-区中。" class="headerlink" title="Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的 Eden 区中。"></a>Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的 Eden 区中。</h5><h5 id="S0-Survivor空间：存在时间长的实例将会从Eden空间移动到S0-Survivor空间"><a href="#S0-Survivor空间：存在时间长的实例将会从Eden空间移动到S0-Survivor空间" class="headerlink" title="S0 Survivor空间：存在时间长的实例将会从Eden空间移动到S0 Survivor空间"></a>S0 Survivor空间：存在时间长的实例将会从Eden空间移动到S0 Survivor空间</h5><h5 id="S1-Survivor空间：存在时间更长的实例将会从S0-Survivor空间移动到S1-Survivor空间"><a href="#S1-Survivor空间：存在时间更长的实例将会从S0-Survivor空间移动到S1-Survivor空间" class="headerlink" title="S1 Survivor空间：存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间"></a>S1 Survivor空间：存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间</h5><h3 id="老年代（Old-Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行-Minor-GC-周期时，在-S1-Survivor-区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。"><a href="#老年代（Old-Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行-Minor-GC-周期时，在-S1-Survivor-区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。" class="headerlink" title="老年代（Old Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行 Minor GC 周期时，在 S1 Survivor 区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。"></a>老年代（Old Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行 Minor GC 周期时，在 S1 Survivor 区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。</h3><h4 id="永久代（Permanent-Generation）包含类、方法等细节的元信息-在Java8中已被移除"><a href="#永久代（Permanent-Generation）包含类、方法等细节的元信息-在Java8中已被移除" class="headerlink" title="永久代（Permanent Generation）包含类、方法等细节的元信息(在Java8中已被移除)"></a>永久代（Permanent Generation）包含类、方法等细节的元信息(在Java8中已被移除)</h4><p>死亡的实例（不再被引用）被标记为垃圾回收。根据垃圾回收器选择的不同，要么被标记的实例都会不停地从内存中移除，要么回收过程会在一个单独的进程中完成。</p>
<p>Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。(当对象在新生代中，经过一次Minor GC如果对象还存活，并且能被新生代内的区域接纳，则使用复制算法将这些仍然存活的对象复制到下一区域，然后清理所使用过的 Eden 以及 s0 区域，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。)<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。(Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长)</p>
<p>碎片整理:一旦实例从堆内存中被删除，其位置就会变空并且可用于未来实例的分配。这些空出的空间将会使整个内存区域碎片化。为了实例的快速分配，需要进行碎片整理。基于垃圾回收器的不同选择，回收的内存区域要么被不停地被整理，要么在一个单独的GC进程中完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/01/16/JAVA_GC/" data-id="cjesiknno0000q4741egeilnj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java中静态块与静态方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/15/Java中静态块与静态方法/" class="article-date">
  <time datetime="2018-01-15T06:07:34.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/Java中静态块与静态方法/">Java中静态块与静态方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、静态块与静态方法："><a href="#一、静态块与静态方法：" class="headerlink" title="一、静态块与静态方法："></a>一、静态块与静态方法：</h2><p>静态代码块是自动执行的，在项目启动时就执行，<br>静态方法是被调用的时候才执行的，在项目启动时就初始化但不执行，在不创建对象的情况下可以被其他程序调用。</p>
<p>静态方法：如果我们在程序编写的时候需要一个不实例化对象就可以调用的方法，我们就可以使用静态方法，具体实现是在方法钱加上static，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、静态方法与非静态方法："><a href="#二、静态方法与非静态方法：" class="headerlink" title="二、静态方法与非静态方法："></a>二、静态方法与非静态方法：</h2><h3 id="1、生命周期（Lifecycle）："><a href="#1、生命周期（Lifecycle）：" class="headerlink" title="1、生命周期（Lifecycle）："></a>1、生命周期（Lifecycle）：</h3><p>静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。</p>
<p>非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 </p>
<h3 id="2、-在内存中存储位置"><a href="#2、-在内存中存储位置" class="headerlink" title="2、 在内存中存储位置"></a>2、 在内存中存储位置</h3><p>静态方法和静态变量创建后始终使用同一块内存，是连续的。</p>
<p>非静态方法会存在于内存的多个地方，是离散的。</p>
<h3 id="3、-效率"><a href="#3、-效率" class="headerlink" title="3、 效率"></a>3、 效率</h3><p> 静态方法的使用效率比非静态方法的效率高。</p>
<h3 id="4、线程安全"><a href="#4、线程安全" class="headerlink" title="4、线程安全"></a>4、线程安全</h3><p>静态方法是共享代码段，静态变量是共享数据段。既然是“共享”就有并发（Concurrence）的问题。</p>
<p>非静态方法是针对确定的一个对象的，所以不会存在线程安全的问题。</p>
<h3 id="5、-使用范围"><a href="#5、-使用范围" class="headerlink" title="5、 使用范围"></a>5、 使用范围</h3><p>静态方法：⒈ 有静态属性的类，一般会定义静态方法。⒉ 没有属性的类，一般会定义静态方法。⒊ 如果一个方法与他所在类的实例对象无关，那么它就应该是静态的。静态方法可以被继承但是不能被覆盖。</p>
<h3 id="6、-总计"><a href="#6、-总计" class="headerlink" title="6、  总计"></a>6、  总计</h3><p>如果静态方法在系统中定义太多，会占用大量的资源，最后造成内存溢出，所以静态方法不能滥用。如果从线程安全、性能、兼容性上来看，选用实例化方法为宜。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/01/15/Java中静态块与静态方法/" data-id="cjesiknop000aq474h66grc5x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读java源码之object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/读java源码之object/" class="article-date">
  <time datetime="2018-01-14T12:35:32.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/读java源码之object/">读java源码之object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读源码只为了更加深刻理解常用类的运用。<br>根据自己的读书经历，发现从原理出发会更感兴趣，如果只是会用和记忆，很快就会忘记。<br>因此，在决定找实习之前重新温习一下Java的源码，希望以后千行bug率能低的离谱好吧。</p>
<h3 id="1-registerNatives"><a href="#1-registerNatives" class="headerlink" title="(1)registerNatives"></a>(1)registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解是:这里是一个调用C语言写成的源程序Java_java_lang_Object_registerNatives,确切的说是JNINativeMethod函数，里面写明了HashCode,Wait,notify,notify,notifyAll,clone。这里不包含Object.getClass()。native是Java调用非Java代码的接口。</p>
<h3 id="2-registerNatives"><a href="#2-registerNatives" class="headerlink" title="(2)registerNatives"></a>(2)registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：这里是调用了registerNatives()方法。在虚拟机的生命周期只调用一次，仅用于初始化。</p>
<h3 id="3-getClass"><a href="#3-getClass" class="headerlink" title="(3)getClass"></a>(3)getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>个人理解：这个方法依然是调用了外部的C语言写的代码，是针对实例（也就是通常所说的对象）的方法，返回值是运行时期才能确定的。与之类似的有一个class()方法，是在编译期就确定的，针对类的方法。当出现继承和多态（父类引用指向子类对象）的时候，getClass返回的则是子类名。</p>
<h3 id="4-hashCode"><a href="#4-hashCode" class="headerlink" title="(4)hashCode"></a>(4)hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：返回一个整数的散列码（HashCode）。两个相同的对象返回的必然是相同的整数结果,不同的对象返回的必然是不同的整数结果。</p>
<h3 id="5-equals"><a href="#5-equals" class="headerlink" title="(5)equals"></a>(5)equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：对比两个对象是否相等，实现了比较两个对象是否相等的功能。如果是e实例非空，e.equals(e)，则恒返回true。如果a.equals(b)返回true,b.equals(c)返回true,则c.equals(a)也必然返回true。非空值equals空值恒返回false。<br>equals在对比基础类型的时候，比的是内容(这里涉及到常量池的问题)，在对比引用类型的时候，比的是地址值。<br>ps：但是，在比较Integer时，-128~127区间内的数值仍然指向常量池。</p>
<h3 id="6-clone"><a href="#6-clone" class="headerlink" title="(6)clone"></a>(6)clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：调用clone方法返回的是一个Object对象。这里clone属性是protected，重载的时候要改成public。在派生类中覆盖Object的clone()方法时，一定要调用super.clone()。<br>    浅层复制： 被复制的对象的所有成员属性都有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅层复制仅仅复制所考虑的对象，而不复制它所引用的对象。（概念不好理解，请结合下文的示例去理解）<br>    深层复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。换而言之，深层复制要复制的对象引用的对象都复制一遍。</p>
<h3 id="7-toString"><a href="#7-toString" class="headerlink" title="(7)toString"></a>(7)toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：简单来说就是将对象的一些特有属性编辑成一个字符串。</p>
<h3 id="8-notify"><a href="#8-notify" class="headerlink" title="(8)notify"></a>(8)notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：通知一个线程重新运行(唤醒),由于重新运行的不知道是哪个线程，所以并不推荐在有两个或以上线程时使用。</p>
<h3 id="9-notifyAll"><a href="#9-notifyAll" class="headerlink" title="(9)notifyAll"></a>(9)notifyAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：与notify相似，不同的是，notifyAll重启(唤醒)的是所有等待中的线程。</p>
<h3 id="10-wait"><a href="#10-wait" class="headerlink" title="(10)wait"></a>(10)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：注册一个常量wait，调用本地的非java代码，并抛出一个线程中断错误。导致当前线程等待，直到调用notify()或者notifyAll()方法，或者在超过指定时间(timeout)后。</p>
<h3 id="11-wait"><a href="#11-wait" class="headerlink" title="(11)wait"></a>(11)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：   timeout：最大等待时间，单位是毫秒。<br>            nanos：附加时间，单位是纳秒，范围是0-999999<br>            附加时间不规范，则抛出异常，如果附加时间大于等于半毫秒，则timeout++(应该是采用四舍五入的思想)，否则舍弃。特殊情况下如果timeout为0，而nanos不为0，则timeout++(同理);最后将timeout值当做参数调用上面(10)注册的wait方法。<br>            猜测：主要是用于更加精确的控制时间，从毫秒级别到纳秒级别是1000*1000倍的关系。这一点点时间看起来或许不是很重要，但如果在高并发的情况下，这一点点的时间代表的是不小量级的资源。</p>
<h3 id="12-wait"><a href="#12-wait" class="headerlink" title="(12)wait"></a>(12)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：如果直接调用wait方法，不传入参数，那么超时时间为0。表示没有唤醒的情况下一直等待。</p>
<p>######在此，个人认为官方提倡的多态是将多种不同形式的参数经过相同方法名但传入参数不同的方法处理后，调用同一个方法。也就是相同方法名不同参数会先进行参数处理，而后调用相同的方法(有的会是在本类中注册的方法，有的则是super的方法)，复用是面向对象的一个特色，减少代码量的同时又不影响效率。</p>
<h3 id="13-finalize"><a href="#13-finalize" class="headerlink" title="(13)finalize"></a>(13)finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：垃圾回收器准备释放内存的时候，会先调用finalize()，但对象不一定会回收，垃圾回收不是析构函数，垃圾回收只与内存有关，垃圾回收和finalize()都是靠不住的，只要JVM没有到快耗尽内存的地步，就不会进行垃圾回收。<br>关键字protected是防止在该类之外定义的代码访问finalize()标识符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/01/14/读java源码之object/" data-id="cjesiknps000uq4741c7eo5c2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/hello-world/" class="article-date">
  <time datetime="2018-01-14T07:38:18.478Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/01/14/hello-world/" data-id="cjesiknos000bq474k3wm73l5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/15/记一次朋友问的sql问题/">记一次朋友问的sql问题</a>
          </li>
        
          <li>
            <a href="/2018/03/15/单层感知器代码/">单层感知器代码</a>
          </li>
        
          <li>
            <a href="/2018/03/15/JupyterNotebook快捷键/">JupyterNotebook快捷键</a>
          </li>
        
          <li>
            <a href="/2018/03/06/Python基础(二)/">Python的基础(二)</a>
          </li>
        
          <li>
            <a href="/2018/02/22/PythonClassLibrary/">PythonClassLibray</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Study/">Study</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/毕设/">毕设</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS/">CS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali/">kali</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/入侵检测/">入侵检测</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 律_Ming<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>