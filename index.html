<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>You&#39;s Tab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Only talented people are qualified to say their dreams">
<meta property="og:type" content="website">
<meta property="og:title" content="You&#39;s Tab">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="You&#39;s Tab">
<meta property="og:description" content="Only talented people are qualified to say their dreams">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="You&#39;s Tab">
<meta name="twitter:description" content="Only talented people are qualified to say their dreams">
  
    <link rel="alternate" href="/atom.xml" title="You&#39;s Tab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">You&#39;s Tab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hobby and Life</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JAVA_GC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/16/JAVA_GC/" class="article-date">
  <time datetime="2018-01-16T07:10:22.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/JAVA_GC/">Java_GC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java的内存分配与回收全部由JVM垃圾回收进程自动完成。与C语言不同，Java开发者不需要自己编写代码实现垃圾回收。<br>程序员可以调用System.gc()和Runtime.gc()来请求JVM启动垃圾回收，但是JVM并不保证这些请求都会执行，启动时间依然取决于堆内存中的Eden区是否可用。</p>
<p>在运行时，Java的实例被存放在堆内存区域。当一个对象不再被引用时，满足条件就会从堆内存移除。在垃圾回收进程中，这些对象将会从堆内存移除并且内存空间被回收。堆内存以下三个主要区域：  </p>
<h3 id="新生代（Young-Generation）：-Eden-s0-s1"><a href="#新生代（Young-Generation）：-Eden-s0-s1" class="headerlink" title="新生代（Young Generation）：)(Eden-s0-s1)"></a>新生代（Young Generation）：)(Eden-s0-s1)</h3><h5 id="Eden空间（Eden-space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的-Eden-区中。"><a href="#Eden空间（Eden-space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的-Eden-区中。" class="headerlink" title="Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的 Eden 区中。"></a>Eden空间（Eden space，任何实例都通过Eden空间进入运行时内存区域）：当一个实例被创建了，首先会被存储在堆内存年轻代的 Eden 区中。</h5><h5 id="S0-Survivor空间：存在时间长的实例将会从Eden空间移动到S0-Survivor空间"><a href="#S0-Survivor空间：存在时间长的实例将会从Eden空间移动到S0-Survivor空间" class="headerlink" title="S0 Survivor空间：存在时间长的实例将会从Eden空间移动到S0 Survivor空间"></a>S0 Survivor空间：存在时间长的实例将会从Eden空间移动到S0 Survivor空间</h5><h5 id="S1-Survivor空间：存在时间更长的实例将会从S0-Survivor空间移动到S1-Survivor空间"><a href="#S1-Survivor空间：存在时间更长的实例将会从S0-Survivor空间移动到S1-Survivor空间" class="headerlink" title="S1 Survivor空间：存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间"></a>S1 Survivor空间：存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间</h5><h3 id="老年代（Old-Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行-Minor-GC-周期时，在-S1-Survivor-区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。"><a href="#老年代（Old-Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行-Minor-GC-周期时，在-S1-Survivor-区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。" class="headerlink" title="老年代（Old Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行 Minor GC 周期时，在 S1 Survivor 区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。"></a>老年代（Old Generation）：是堆内存中的第二块逻辑区。当垃圾回收器执行 Minor GC 周期时，在 S1 Survivor 区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。</h3><h4 id="永久代（Permanent-Generation）包含类、方法等细节的元信息-在Java8中已被移除"><a href="#永久代（Permanent-Generation）包含类、方法等细节的元信息-在Java8中已被移除" class="headerlink" title="永久代（Permanent Generation）包含类、方法等细节的元信息(在Java8中已被移除)"></a>永久代（Permanent Generation）包含类、方法等细节的元信息(在Java8中已被移除)</h4><p>死亡的实例（不再被引用）被标记为垃圾回收。根据垃圾回收器选择的不同，要么被标记的实例都会不停地从内存中移除，要么回收过程会在一个单独的进程中完成。</p>
<p>Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。<br>Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。(当对象在新生代中，经过一次Minor GC如果对象还存活，并且能被新生代内的区域接纳，则使用复制算法将这些仍然存活的对象复制到下一区域，然后清理所使用过的 Eden 以及 s0 区域，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。)<br>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。(Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长)</p>
<p>碎片整理:一旦实例从堆内存中被删除，其位置就会变空并且可用于未来实例的分配。这些空出的空间将会使整个内存区域碎片化。为了实例的快速分配，需要进行碎片整理。基于垃圾回收器的不同选择，回收的内存区域要么被不停地被整理，要么在一个单独的GC进程中完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/16/JAVA_GC/" data-id="cjchbaxep00008474hfqynhs0" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java中静态块与静态方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/15/Java中静态块与静态方法/" class="article-date">
  <time datetime="2018-01-15T06:07:34.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/Java中静态块与静态方法/">Java中静态块与静态方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、静态块与静态方法："><a href="#一、静态块与静态方法：" class="headerlink" title="一、静态块与静态方法："></a>一、静态块与静态方法：</h2><p>静态代码块是自动执行的，在项目启动时就执行，<br>静态方法是被调用的时候才执行的，在项目启动时就初始化但不执行，在不创建对象的情况下可以被其他程序调用。</p>
<p>静态方法：如果我们在程序编写的时候需要一个不实例化对象就可以调用的方法，我们就可以使用静态方法，具体实现是在方法钱加上static，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、静态方法与非静态方法："><a href="#二、静态方法与非静态方法：" class="headerlink" title="二、静态方法与非静态方法："></a>二、静态方法与非静态方法：</h2><h3 id="1、生命周期（Lifecycle）："><a href="#1、生命周期（Lifecycle）：" class="headerlink" title="1、生命周期（Lifecycle）："></a>1、生命周期（Lifecycle）：</h3><p>静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。</p>
<p>非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。 </p>
<h3 id="2、-在内存中存储位置"><a href="#2、-在内存中存储位置" class="headerlink" title="2、 在内存中存储位置"></a>2、 在内存中存储位置</h3><p>静态方法和静态变量创建后始终使用同一块内存，是连续的。</p>
<p>非静态方法会存在于内存的多个地方，是离散的。</p>
<h3 id="3、-效率"><a href="#3、-效率" class="headerlink" title="3、 效率"></a>3、 效率</h3><p> 静态方法的使用效率比非静态方法的效率高。</p>
<h3 id="4、线程安全"><a href="#4、线程安全" class="headerlink" title="4、线程安全"></a>4、线程安全</h3><p>静态方法是共享代码段，静态变量是共享数据段。既然是“共享”就有并发（Concurrence）的问题。</p>
<p>非静态方法是针对确定的一个对象的，所以不会存在线程安全的问题。</p>
<h3 id="5、-使用范围"><a href="#5、-使用范围" class="headerlink" title="5、 使用范围"></a>5、 使用范围</h3><p>静态方法：⒈ 有静态属性的类，一般会定义静态方法。⒉ 没有属性的类，一般会定义静态方法。⒊ 如果一个方法与他所在类的实例对象无关，那么它就应该是静态的。静态方法可以被继承但是不能被覆盖。</p>
<h3 id="6、-总计"><a href="#6、-总计" class="headerlink" title="6、  总计"></a>6、  总计</h3><p>如果静态方法在系统中定义太多，会占用大量的资源，最后造成内存溢出，所以静态方法不能滥用。如果从线程安全、性能、兼容性上来看，选用实例化方法为宜。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/15/Java中静态块与静态方法/" data-id="cjchbaxf500048474ka2dlx5g" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读java源码之object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/读java源码之object/" class="article-date">
  <time datetime="2018-01-14T12:35:32.000Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/读java源码之object/">读java源码之object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阅读源码只为了更加深刻理解常用类的运用。<br>根据自己的读书经历，发现从原理出发会更感兴趣，如果只是会用和记忆，很快就会忘记。<br>因此，在决定找实习之前重新温习一下Java的源码，希望以后千行bug率能低的离谱好吧。</p>
<h3 id="1-registerNatives"><a href="#1-registerNatives" class="headerlink" title="(1)registerNatives"></a>(1)registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解是:这里是一个调用C语言写成的源程序Java_java_lang_Object_registerNatives,确切的说是JNINativeMethod函数，里面写明了HashCode,Wait,notify,notify,notifyAll,clone。这里不包含Object.getClass()。native是Java调用非Java代码的接口。</p>
<h3 id="2-registerNatives"><a href="#2-registerNatives" class="headerlink" title="(2)registerNatives"></a>(2)registerNatives</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：这里是调用了registerNatives()方法。在虚拟机的生命周期只调用一次，仅用于初始化。</p>
<h3 id="3-getClass"><a href="#3-getClass" class="headerlink" title="(3)getClass"></a>(3)getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>个人理解：这个方法依然是调用了外部的C语言写的代码，是针对实例（也就是通常所说的对象）的方法，返回值是运行时期才能确定的。与之类似的有一个class()方法，是在编译期就确定的，针对类的方法。当出现继承和多态（父类引用指向子类对象）的时候，getClass返回的则是子类名。</p>
<h3 id="4-hashCode"><a href="#4-hashCode" class="headerlink" title="(4)hashCode"></a>(4)hashCode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：返回一个整数的散列码（HashCode）。两个相同的对象返回的必然是相同的整数结果,不同的对象返回的必然是不同的整数结果。</p>
<h3 id="5-equals"><a href="#5-equals" class="headerlink" title="(5)equals"></a>(5)equals</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：对比两个对象是否相等，实现了比较两个对象是否相等的功能。如果是e实例非空，e.equals(e)，则恒返回true。如果a.equals(b)返回true,b.equals(c)返回true,则c.equals(a)也必然返回true。非空值equals空值恒返回false。<br>equals在对比基础类型的时候，比的是内容(这里涉及到常量池的问题)，在对比引用类型的时候，比的是地址值。<br>ps：但是，在比较Integer时，-128~127区间内的数值仍然指向常量池。</p>
<h3 id="6-clone"><a href="#6-clone" class="headerlink" title="(6)clone"></a>(6)clone</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：调用clone方法返回的是一个Object对象。这里clone属性是protected，重载的时候要改成public。在派生类中覆盖Object的clone()方法时，一定要调用super.clone()。<br>    浅层复制： 被复制的对象的所有成员属性都有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅层复制仅仅复制所考虑的对象，而不复制它所引用的对象。（概念不好理解，请结合下文的示例去理解）<br>    深层复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。换而言之，深层复制要复制的对象引用的对象都复制一遍。</p>
<h3 id="7-toString"><a href="#7-toString" class="headerlink" title="(7)toString"></a>(7)toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：简单来说就是将对象的一些特有属性编辑成一个字符串。</p>
<h3 id="8-notify"><a href="#8-notify" class="headerlink" title="(8)notify"></a>(8)notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：通知一个线程重新运行(唤醒),由于重新运行的不知道是哪个线程，所以并不推荐在有两个或以上线程时使用。</p>
<h3 id="9-notifyAll"><a href="#9-notifyAll" class="headerlink" title="(9)notifyAll"></a>(9)notifyAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：与notify相似，不同的是，notifyAll重启(唤醒)的是所有等待中的线程。</p>
<h3 id="10-wait"><a href="#10-wait" class="headerlink" title="(10)wait"></a>(10)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>个人理解：注册一个常量wait，调用本地的非java代码，并抛出一个线程中断错误。导致当前线程等待，直到调用notify()或者notifyAll()方法，或者在超过指定时间(timeout)后。</p>
<h3 id="11-wait"><a href="#11-wait" class="headerlink" title="(11)wait"></a>(11)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：   timeout：最大等待时间，单位是毫秒。<br>            nanos：附加时间，单位是纳秒，范围是0-999999<br>            附加时间不规范，则抛出异常，如果附加时间大于等于半毫秒，则timeout++(应该是采用四舍五入的思想)，否则舍弃。特殊情况下如果timeout为0，而nanos不为0，则timeout++(同理);最后将timeout值当做参数调用上面(10)注册的wait方法。<br>            猜测：主要是用于更加精确的控制时间，从毫秒级别到纳秒级别是1000*1000倍的关系。这一点点时间看起来或许不是很重要，但如果在高并发的情况下，这一点点的时间代表的是不小量级的资源。</p>
<h3 id="12-wait"><a href="#12-wait" class="headerlink" title="(12)wait"></a>(12)wait</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：如果直接调用wait方法，不传入参数，那么超时时间为0。表示没有唤醒的情况下一直等待。</p>
<p>######在此，个人认为官方提倡的多态是将多种不同形式的参数经过相同方法名但传入参数不同的方法处理后，调用同一个方法。也就是相同方法名不同参数会先进行参数处理，而后调用相同的方法(有的会是在本类中注册的方法，有的则是super的方法)，复用是面向对象的一个特色，减少代码量的同时又不影响效率。</p>
<h3 id="13-finalize"><a href="#13-finalize" class="headerlink" title="(13)finalize"></a>(13)finalize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>个人理解：垃圾回收器准备释放内存的时候，会先调用finalize()，但对象不一定会回收，垃圾回收不是析构函数，垃圾回收只与内存有关，垃圾回收和finalize()都是靠不住的，只要JVM没有到快耗尽内存的地步，就不会进行垃圾回收。<br>关键字protected是防止在该类之外定义的代码访问finalize()标识符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/14/读java源码之object/" data-id="cjchbaxf800058474pwfqn50g" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/14/hello-world/" class="article-date">
  <time datetime="2018-01-14T07:38:18.478Z" itemprop="datePublished">2018-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/14/hello-world/" data-id="cjchbaxey000184741sq4e3iw" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/16/JAVA_GC/">Java_GC</a>
          </li>
        
          <li>
            <a href="/2018/01/15/Java中静态块与静态方法/">Java中静态块与静态方法</a>
          </li>
        
          <li>
            <a href="/2018/01/14/读java源码之object/">读java源码之object</a>
          </li>
        
          <li>
            <a href="/2018/01/14/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Study/">Study</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 律_Ming<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>