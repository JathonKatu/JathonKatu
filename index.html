<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>You&#39;s Tab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Only talented people are qualified to say their dreams">
<meta property="og:type" content="website">
<meta property="og:title" content="You&#39;s Tab">
<meta property="og:url" content="https://jathonkatu.github.io/index.html">
<meta property="og:site_name" content="You&#39;s Tab">
<meta property="og:description" content="Only talented people are qualified to say their dreams">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="You&#39;s Tab">
<meta name="twitter:description" content="Only talented people are qualified to say their dreams">
  
    <link rel="alternate" href="/atom.xml" title="You&#39;s Tab" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">You&#39;s Tab</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hobby and Life</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jathonkatu.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java面经" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/13/Java面经/" class="article-date">
  <time datetime="2018-07-12T16:13:56.000Z" itemprop="datePublished">2018-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/13/Java面经/">Java面经</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、JAVA基础篇-概念"><a href="#一、JAVA基础篇-概念" class="headerlink" title="一、JAVA基础篇-概念"></a>一、JAVA基础篇-概念</h3><h6 id="1-简述你所知道的Linux："><a href="#1-简述你所知道的Linux：" class="headerlink" title="1.简述你所知道的Linux："></a>1.简述你所知道的Linux：</h6><p>Linux起源于1991年，1995年流行起来的免费操作系统，目前， Linux是主流的服务器操作系统， 广泛应用于互联网、云计算、智能手机（Android）等领域。由于Java主要用于服务器端的开发，因此Java应用的部署环境有很多为Linux。<br>Windows操作系统的目录结构，是以盘符为单位，C盘、D盘、E盘等等，数据存储在各个盘符之下，而Linux操作系统最顶层只有一个根目录root，所有文件都存储在这一个根目录之下。<br>Linux不像Windows的图形操作界面，是通过命令的方式进行操作，常用命令有：<br>a . pwd：用于显示当前工作目录；<br>b . ls：用于查看当前工作目录内容；<br>c . cd：用于改变当前工作目录。</p>
<h6 id="2-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#2-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="2.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>2.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h6><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h6 id="3-JDK、JRE、JVM关系是什么？"><a href="#3-JDK、JRE、JVM关系是什么？" class="headerlink" title="3.JDK、JRE、JVM关系是什么？"></a>3.JDK、JRE、JVM关系是什么？</h6><p>JDK（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。开发工具如：用于编译java程序的javac命令、用于启动JVM运行java程序的java命令、用于生成文档的javadoc命令以及用于打包的jar命令等等。<br>JRE（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。<br>JVM（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。<br>简单说，就是JDK包含JRE包含JVM。</p>
<h6 id="4-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#4-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="4.Java支持的数据类型有哪些？什么是自动拆装箱？"></a>4.Java支持的数据类型有哪些？什么是自动拆装箱？</h6><p>基本数据类型：<br>整数值型：byte,short,int,long,<br>字符型：char<br>浮点类型：float,double<br>布尔型：boolean<br>整数默认int型，小数默认是double型。Float和long类型的必须加后缀。</p>
<p>首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。<br>而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。</p>
<h6 id="5-面向对象是什么？"><a href="#5-面向对象是什么？" class="headerlink" title="5.面向对象是什么？"></a>5.面向对象是什么？</h6><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java是一个支持并发、基于类和面向对象的计算机编程语言，面向对象软件开发的优点：<br>代码开发模块化，更易维护和修改；<br>代码复用性强；<br>增强代码的可靠性和灵活性；<br>增加代码的可读性。<br>1<br>2<br>3<br>4<br>5<br>6<br>面向对象的四大基本特性：<br>抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。</p>
<p>封装：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等）</p>
<p>继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。</p>
<p>多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。</p>
<p>抽象、封装、继承和多态是面向对象的基础。在面向对象四大基础特性之上，我们在做面向对象编程设计时还需要遵循有一些基本的设计原则。</p>
<p>面向对象的七大设计原则：<br>SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则）<br>迪米特法则<br>组合优于继承原则（合成复用原则）。<br>在遵循这些面向对象设计原则基础上，前辈们总结出一些解决不同问题场景的设计模式，以四人帮的gof23最为知名。</p>
<p>24种设计模式(gof23+1)：<br>创建型模式：<br>1.简单工厂模式（不包含在gof23中）<br>2.工厂模式<br>3.抽象工厂模式<br>4.单例模式<br>5.原型模式<br>创建者模式<br>6.结构型模式：<br>7.组合模式<br>8.装饰者模式<br>9.外观模式<br>10.适配器模式<br>11.代理模式<br>12.享元模式<br>13.桥接模式<br>行为型模式：<br>14.观察者模式<br>15.策略模式<br>16.状态模式<br>17.中介模式<br>18.模板方法<br>19.命令模式<br>20.备忘录模式<br>21.访问者模式<br>22.解释器模式<br>23.迭代器模式<br>24.职责链模式<br>这里只是简单描述了定义和特征以及设计模式的关系，具体细节不讨论。</p>
<h6 id="6-请写出下面几个表达式的结果，答案可以用10进制或16进制书写"><a href="#6-请写出下面几个表达式的结果，答案可以用10进制或16进制书写" class="headerlink" title="6.请写出下面几个表达式的结果，答案可以用10进制或16进制书写"></a>6.请写出下面几个表达式的结果，答案可以用10进制或16进制书写</h6><p>1). 0xaa | 0x55<br>2). 15 &amp; 240<br>3). 10 ^ 12<br>4). -2 &gt;&gt; 1<br>5). -2 &gt;&gt;&gt; 1<br>1). 分析：十六进制数用0x……来表示，后面一个十六进制位是四位，两个十六进制位为一个字节，最多后面可以有8个十六进制位，32个字节,如：0xFFFFFFFF。 或（“ | ”）运算，全0为0，其他为1。<br>所以：0xaa 用二进制表示为 10101010 ,0x55 用二进制表示为 01010101 ,按位或之后为 11111111 ，十进制数为255，十六进制数为 0xFF 。</p>
<p>2). 分析：10进制转换成2进制，用该数字除以2，记录商和余数，利用商再次除以2，记录商和余数……直到上为0或余数为0停止，余数逆序组成二进制的从低到高位（最后的余数为二进制最低位）。与（“ &amp; ”）运算，全1为1，其他为0 。<br>所以： 15 等于1111 ，240等于 11110000，15前面用0补齐为00001111 ，按位与之后为 00000000 ，即结果为0</p>
<p>3). 分析： 亦或（“ ^ ”）运算，相同取0，不同取1 。<br>所以：1010 ^ 1100 =0110 , 十进制表示为6，十六进制表示为 0x06 。</p>
<p>4). 分析： 带符号右移（“ &gt;&gt; ”），即有符号位时，负数符号位补1，正数符号位补0， -2 的二进制求法是正数取反加1，因此 2 的二进制表示为0000 0000 0000 0000 0000 0000 0000 0010 ，取反加一为<br>1111 1111 1111 1111 1111 1111 1111 1110 ，即 -2 的二进制表示。<br>注： &gt;&gt; , &lt;&lt; , &gt;&gt;&gt; , 运算符只针对int型和long型，byte ,short ,char型需要转换成Int型在进行操作。<br>所以： 带符号右移之后为 1111 1111 1111 1111 1111 1111 1111 1111 ，除符号位之外，减一取反，得到带符号十进 制数为 -1 。</p>
<p>5). 分析：无符号右移 (“ &gt;&gt;&gt; ”) ，即无论正负数，右移之后符号位均补 0 。<br>所以： -2 的二进制无符号右移一位之后为 0111 1111 1111 1111 1111 1111 1111 1111，即 2^31 - 1,二的三十一次方减一。<br>注：右移和无符号右移主要区别就在于左面最高位补 0 还是补 1 的问题，无符号右移任何时候最高位都补 0 ， 有符号右移则是正数补 0 ，负数补 1 。（没有无符号左移！）。</p>
<h6 id="7-amp-和-amp-amp-的区别？"><a href="#7-amp-和-amp-amp-的区别？" class="headerlink" title="7.&amp;和&amp;&amp;的区别？"></a>7.&amp;和&amp;&amp;的区别？</h6><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h6 id="8-什么是值传递和引用传递？"><a href="#8-什么是值传递和引用传递？" class="headerlink" title="8.什么是值传递和引用传递？"></a>8.什么是值传递和引用传递？</h6><p>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.<br>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。<br>一般认为,java内的传递都是值传递. java中实例对象的传递是引用传递 。</p>
<h6 id="9-是否可以在static环境中访问非static变量？"><a href="#9-是否可以在static环境中访问非static变量？" class="headerlink" title="9.是否可以在static环境中访问非static变量？"></a>9.是否可以在static环境中访问非static变量？</h6><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h6 id="10-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#10-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="10.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>10.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h6><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p>
<h6 id="11-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#11-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="11.Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>11.Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h6><p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。<br>Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</p>
<h6 id="12-Java支持多继承么？"><a href="#12-Java支持多继承么？" class="headerlink" title="12.Java支持多继承么？"></a>12.Java支持多继承么？</h6><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p>
<h6 id="13-解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#13-解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="13.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>13.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h6><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。</p>
<h6 id="14-接口和抽象类的区别是什么？"><a href="#14-接口和抽象类的区别是什么？" class="headerlink" title="14.接口和抽象类的区别是什么？"></a>14.接口和抽象类的区别是什么？</h6><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：<br>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>也可以参考JDK8中抽象类和接口的区别。</p>
<h6 id="15-用最有效率的方法计算2乘以8？"><a href="#15-用最有效率的方法计算2乘以8？" class="headerlink" title="15.用最有效率的方法计算2乘以8？"></a>15.用最有效率的方法计算2乘以8？</h6><p>答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<h6 id="16-手写单例模式（饿汉和饱汉模式）和工厂模式？"><a href="#16-手写单例模式（饿汉和饱汉模式）和工厂模式？" class="headerlink" title="16.手写单例模式（饿汉和饱汉模式）和工厂模式？"></a>16.手写单例模式（饿汉和饱汉模式）和工厂模式？</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)单例饿汉模式:<span class="comment">//饿汉式单例类.在类初始化时，已经自行实例化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123; </span><br><span class="line">    <span class="comment">//私有的默认构造子 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    <span class="comment">//已经自行实例化 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 single = <span class="keyword">new</span> Singleton1(); </span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> single; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)懒汉模式://懒汉式单例类.在第一次调用的时候实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123; </span><br><span class="line">    <span class="comment">//私有的默认构造子 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    <span class="comment">//注意，这里没有final </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 single=<span class="keyword">null</span>; </span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123; </span><br><span class="line">            single = <span class="keyword">new</span> Singleton2(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> single; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">3</span>)工厂模式: </span><br><span class="line">```Java</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125; </span><br><span class="line">Class Factory implements IFactory&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    Public <span class="class"><span class="keyword">class</span> <span class="title">client</span></span>&#123; </span><br><span class="line">    <span class="function">Public Static <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        IFactory factory=<span class="keyword">new</span> Factory(); </span><br><span class="line">        IProduct product=factory.createProduct(); </span><br><span class="line">        product.ProductMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="17-String和StringBuilder、StringBuffer的区别？"><a href="#17-String和StringBuilder、StringBuffer的区别？" class="headerlink" title="17.String和StringBuilder、StringBuffer的区别？"></a>17.String和StringBuilder、StringBuffer的区别？</h6><p>Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</p>
<h3 id="二、JAVA基础篇-集合与数组"><a href="#二、JAVA基础篇-集合与数组" class="headerlink" title="二、JAVA基础篇-集合与数组"></a>二、JAVA基础篇-集合与数组</h3><h6 id="18-Java集合框架是什么？说出一些集合框架的优点？"><a href="#18-Java集合框架是什么？说出一些集合框架的优点？" class="headerlink" title="18.Java集合框架是什么？说出一些集合框架的优点？"></a>18.Java集合框架是什么？说出一些集合框架的优点？</h6><p>每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：<br>（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。<br>（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。<br>（3）通过使用JDK附带的集合类，可以降低代码维护成本。<br>（4）复用性和可操作性。</p>
<h6 id="19-集合框架中的泛型有什么优点？"><a href="#19-集合框架中的泛型有什么优点？" class="headerlink" title="19.集合框架中的泛型有什么优点？"></a>19.集合框架中的泛型有什么优点？</h6><p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h6 id="20-Java集合框架的基础接口有哪些？"><a href="#20-Java集合框架的基础接口有哪些？" class="headerlink" title="20.Java集合框架的基础接口有哪些？"></a>20.Java集合框架的基础接口有哪些？</h6><p>Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。## 标题 ##<br>Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。<br>List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。<br>Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。<br>一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。</p>
<h6 id="21-为何Collection不从Cloneable和Serializable接口继承？"><a href="#21-为何Collection不从Cloneable和Serializable接口继承？" class="headerlink" title="21.为何Collection不从Cloneable和Serializable接口继承？"></a>21.为何Collection不从Cloneable和Serializable接口继承？</h6><p>Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。<br>当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。<br>在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。</p>
<h6 id="22-为何Map接口不继承Collection接口？"><a href="#22-为何Map接口不继承Collection接口？" class="headerlink" title="22.为何Map接口不继承Collection接口？"></a>22.为何Map接口不继承Collection接口？</h6><p>尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。<br>如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。</p>
<h6 id="23-什么是迭代器-Iterator-？"><a href="#23-什么是迭代器-Iterator-？" class="headerlink" title="23.什么是迭代器(Iterator)？"></a>23.什么是迭代器(Iterator)？</h6><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p>
<h6 id="24-Iterator和ListIterator的区别是什么？"><a href="#24-Iterator和ListIterator的区别是什么？" class="headerlink" title="24.Iterator和ListIterator的区别是什么？"></a>24.Iterator和ListIterator的区别是什么？</h6><p>下面列出了他们的区别：<br>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h6 id="25-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#25-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="25.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>25.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h6><p>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。<br>在java.util包下的都是快速失败。<br>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。<br>在java.util.concurrent包下的全是安全失败的。</p>
<h6 id="26-Java中的HashMap的工作原理是什么？"><a href="#26-Java中的HashMap的工作原理是什么？" class="headerlink" title="26.Java中的HashMap的工作原理是什么？"></a>26.Java中的HashMap的工作原理是什么？</h6><p>我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：最左侧是一个数组，数组中的每一个元素都是一个链表，链表的每一个元素都是entry。</p>
<p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。</p>
<h6 id="27-当两个对象的hashcode相同会发生什么？"><a href="#27-当两个对象的hashcode相同会发生什么？" class="headerlink" title="27.当两个对象的hashcode相同会发生什么？"></a>27.当两个对象的hashcode相同会发生什么？</h6><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p>
<h6 id="28-如果两个键的hashcode相同，你如何获取值对象？"><a href="#28-如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="28.如果两个键的hashcode相同，你如何获取值对象？"></a>28.如果两个键的hashcode相同，你如何获取值对象？</h6><p>当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。</p>
<h6 id="29-hashCode-和equals-方法有何重要性？"><a href="#29-hashCode-和equals-方法有何重要性？" class="headerlink" title="29.hashCode()和equals()方法有何重要性？"></a>29.hashCode()和equals()方法有何重要性？</h6><p>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：<br>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。<br>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。<br>具体可以参考 <a href="http://blog.csdn.net/javazejian/article/details/51348320" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/51348320</a></p>
<h6 id="30-HashMap和Hashtable有什么区别？"><a href="#30-HashMap和Hashtable有什么区别？" class="headerlink" title="30.HashMap和Hashtable有什么区别？"></a>30.HashMap和Hashtable有什么区别？</h6><p>1、HashMap是非线程安全的，HashTable是线程安全的。<br>2、HashMap的键和值都允许有null值存在，而HashTable则不行。<br>3、因为线程安全的问题，HashMap效率比HashTable的要高。<br>4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。<br>一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。</p>
<h6 id="31-如何决定选用HashMap还是TreeMap？"><a href="#31-如何决定选用HashMap还是TreeMap？" class="headerlink" title="31.如何决定选用HashMap还是TreeMap？"></a>31.如何决定选用HashMap还是TreeMap？</h6><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>
<h6 id="32-ArrayList和Vector有何异同点？"><a href="#32-ArrayList和Vector有何异同点？" class="headerlink" title="32.ArrayList和Vector有何异同点？"></a>32.ArrayList和Vector有何异同点？</h6><p>ArrayList和Vector在很多时候都很类似。<br>（1）两者都是基于索引的，内部由一个数组支持。<br>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。<br>（3）ArrayList和Vector的迭代器实现都是fail-fast的。<br>（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。<br>以下是ArrayList和Vector的不同点。<br>（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。<br>（2）ArrayList比Vector快，它因为有同步，不会过载。<br>（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
<h6 id="33-Array和ArrayList有何区别？什么时候更适合用Array？"><a href="#33-Array和ArrayList有何区别？什么时候更适合用Array？" class="headerlink" title="33.Array和ArrayList有何区别？什么时候更适合用Array？"></a>33.Array和ArrayList有何区别？什么时候更适合用Array？</h6><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。<br>（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。<br>（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。<br>（3）如果你要使用多维数组，使用[][]比List</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/07/13/Java面经/" data-id="cjjird1bx000gmw74dly0xw30" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/JAVA设计模式/" class="article-date">
  <time datetime="2018-07-12T13:17:35.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/JAVA设计模式/">JAVA设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java的设计模式大体上分为三大类：<br>创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。<br>结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。<br>行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>设计模式遵循的原则有6个：</p>
<h4 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h4><p>　　对扩展开放，对修改关闭。</p>
<h4 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h4><p>　　只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p>
<h4 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h4><p>　　这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。</p>
<h4 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h4><p>　　使用多个隔离的借口来降低耦合度。</p>
<h4 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h4><p>　　一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h4 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h4><p>　　原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。</p>
<h5 id="1-工厂模式（Factory-Method）"><a href="#1-工厂模式（Factory-Method）" class="headerlink" title="1. 工厂模式（Factory Method）"></a>1. 工厂模式（Factory Method）</h5><p>　　常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> food <span class="title">getA</span><span class="params">()</span></span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> A(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> food <span class="title">getB</span><span class="params">()</span></span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> B(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> food <span class="title">getC</span><span class="params">()</span></span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> C(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="comment">//客户端代码只需要将相应的参数传入即可得到对象</span></span><br><span class="line">    <span class="comment">//用户不需要了解工厂类内部的逻辑。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        food x = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">if</span> ( name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            x = StaticFactory.getA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( name.equals(<span class="string">"B"</span>))&#123;</span><br><span class="line">            x = StaticFactory.getB();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            x = StaticFactory.getC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-抽象工厂模式（Abstract-Factory）"><a href="#2-抽象工厂模式（Abstract-Factory）" class="headerlink" title="2. 抽象工厂模式（Abstract Factory）"></a>2. 抽象工厂模式（Abstract Factory）</h5><p>　　一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。</p>
<p>　　抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">produce</span></span>&#123; <span class="function">food <span class="title">get</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryForA</span> <span class="keyword">implements</span> <span class="title">produce</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> food <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryForB</span> <span class="keyword">implements</span> <span class="title">produce</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> food <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        food x= <span class="keyword">new</span> FactoryForA().get();</span><br><span class="line">        x = <span class="keyword">new</span> FactoryForB().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3. 单例模式（Singleton）"></a>3. 单例模式（Singleton）</h5><p> 　　在内部创建一个实例，构造器全部设置为private，所有方法均在该实例上改动，在创建上要注意类的实例化只能执行一次，可以采用许多种方法来实现，如Synchronized关键字，或者利用内部类等机制来实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBuild</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton value = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  <span class="keyword">return</span>  SingletonBuild.value ;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4-建造者模式（Builder）"><a href="#4-建造者模式（Builder）" class="headerlink" title="4.建造者模式（Builder）"></a>4.建造者模式（Builder）</h5><p>　　在了解之前，先假设有一个问题，我们需要创建一个学生对象，属性有name,number,class,sex,age,school等属性，如果每一个属性都可以为空，也就是说我们可以只用一个name,也可以用一个school,name,或者一个class,number，或者其他任意的赋值来创建一个学生对象，这时该怎么构造？</p>
<p>　　难道我们写6个1个输入的构造函数，15个2个输入的构造函数…….吗？这个时候就需要用到Builder模式了。给个例子，大家肯定一看就懂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">        String name = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">int</span> number = -<span class="number">1</span> ;</span><br><span class="line">        String sex = <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">int</span> age = -<span class="number">1</span> ;</span><br><span class="line">        String school = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">　　　　　<span class="comment">//构建器，利用构建器作为参数来构建Student对象</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentBuilder</span></span>&#123;</span><br><span class="line">            String name = <span class="keyword">null</span> ;</span><br><span class="line">            <span class="keyword">int</span> number = -<span class="number">1</span> ;</span><br><span class="line">            String sex = <span class="keyword">null</span> ;</span><br><span class="line">            <span class="keyword">int</span> age = -<span class="number">1</span> ;</span><br><span class="line">            String school = <span class="keyword">null</span> ;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">this</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.number = number;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">this</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.sex = sex;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">this</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">this</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> StudentBuilder <span class="title">setSchool</span><span class="params">(String school)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.school = school;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">this</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Student <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(StudentBuilder builder)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = builder.age;</span><br><span class="line">            <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">            <span class="keyword">this</span>.number = builder.number;</span><br><span class="line">            <span class="keyword">this</span>.school = builder.school ;</span><br><span class="line">            <span class="keyword">this</span>.sex = builder.sex ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span>&#123;</span><br><span class="line">        Student a = <span class="keyword">new</span> Student.StudentBuilder().setAge(<span class="number">13</span>).setName(<span class="string">"LiHua"</span>).build();</span><br><span class="line">        Student b = <span class="keyword">new</span> Student.StudentBuilder().setSchool(<span class="string">"sc"</span>).setSex(<span class="string">"Male"</span>).setName(<span class="string">"ZhangSan"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-原型模式（Protype）"><a href="#5-原型模式（Protype）" class="headerlink" title="5. 原型模式（Protype）"></a>5. 原型模式（Protype）</h5><p>原型模式就是讲一个对象作为原型，使用clone()方法来创建新的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">( String[] args)</span></span>&#123;</span><br><span class="line">        Prototype pro = <span class="keyword">new</span> Prototype();</span><br><span class="line">        Prototype pro1 = (Prototype)pro.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处使用的是浅拷贝，关于深浅拷贝，大家可以另行查找相关资料。</p>
<h5 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6.适配器模式（Adapter）"></a>6.适配器模式（Adapter）</h5><p>适配器模式的作用就是在原来的类上提供新功能。主要可分为3种：</p>
<p>类适配：创建新类，继承源类，并实现新接口，例如<br>class  adapter extends oldClass  implements newFunc{}<br>对象适配：创建新类持源类的实例，并实现新接口，例如<br>class adapter implements newFunc { private oldClass oldInstance ;}<br>接口适配：创建新的抽象类实现旧接口方法。例如<br>abstract class adapter implements oldClassFunc { void newFunc();}</p>
<h5 id="7-装饰模式（Decorator）"><a href="#7-装饰模式（Decorator）" class="headerlink" title="7.装饰模式（Decorator）"></a>7.装饰模式（Decorator）</h5><p> 给一类对象增加新的功能，装饰方法与具体的内部逻辑无关。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Source</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Source</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Source source ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decotate1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"decorate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        decotate1();</span><br><span class="line">        source.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="8-代理模式（Proxy）"><a href="#8-代理模式（Proxy）" class="headerlink" title="8.代理模式（Proxy）"></a>8.代理模式（Proxy）</h5><p>客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。</p>
<p>这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Source</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldClass</span> <span class="keyword">implements</span> <span class="title">Source</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Source</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Source source = <span class="keyword">new</span> OldClass();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Class1().Func1();</span><br><span class="line">        source.method();</span><br><span class="line">        <span class="keyword">new</span> Class2().Func2();</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="9-外观模式（Facade）"><a href="#9-外观模式（Facade）" class="headerlink" title="9.外观模式（Facade）"></a>9.外观模式（Facade）</h5><p>为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。这句话是百度百科的解释，有点难懂，但是没事，看下面的例子，我们在启动停止所有子系统的时候，为它们设计一个外观类，这样就可以实现统一的接口，这样即使有新增的子系统subSystem4,也可以在不修改客户端代码的情况下轻松完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> subSystem1 subSystem1 = <span class="keyword">new</span> subSystem1();</span><br><span class="line">    <span class="keyword">private</span> subSystem2 subSystem2 = <span class="keyword">new</span> subSystem2();</span><br><span class="line">    <span class="keyword">private</span> subSystem3 subSystem3 = <span class="keyword">new</span> subSystem3();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        subSystem1.start();</span><br><span class="line">        subSystem2.start();</span><br><span class="line">        subSystem3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        subSystem1.stop();</span><br><span class="line">        subSystem2.stop();</span><br><span class="line">        subSystem3.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="10-桥接模式（Bridge）"><a href="#10-桥接模式（Bridge）" class="headerlink" title="10.桥接模式（Bridge）"></a>10.桥接模式（Bridge）</h5><p>这里引用下<a href="http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码：" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/bridge-pattern.html的例子。Circle类将DrwaApi与Shape类进行了桥接，代码：</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drawing Circle[ color: red, radius: "</span></span><br><span class="line">                + radius +<span class="string">", x: "</span> +x+<span class="string">", "</span>+ y +<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drawing Circle[ color: green, radius: "</span></span><br><span class="line">                + radius +<span class="string">", x: "</span> +x+<span class="string">", "</span>+ y +<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y, radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawAPI.drawCircle(radius,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端使用代码</span></span><br><span class="line">Shape redCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> RedCircle());</span><br><span class="line">Shape greenCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> GreenCircle());</span><br><span class="line">redCircle.draw();</span><br><span class="line">greenCircle.draw();</span><br></pre></td></tr></table></figure></p>
<h5 id="11-组合模式（Composite）"><a href="#11-组合模式（Composite）" class="headerlink" title="11.组合模式（Composite）"></a>11.组合模式（Composite）</h5><p> 组合模式是为了表示那些层次结构，同时部分和整体也可能是一样的结构，常见的如文件夹或者树。举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">component</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span>  <span class="title">component</span></span>&#123; String filename;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span>  <span class="title">component</span></span>&#123;</span><br><span class="line">    component[] files ;  <span class="comment">//既可以放文件File类，也可以放文件夹Folder类。Folder类下又有子文件或子文件夹。</span></span><br><span class="line">    String foldername ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(component[] source)</span></span>&#123; files = source ;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( component f:files)&#123;</span><br><span class="line">            <span class="keyword">if</span> ( f <span class="keyword">instanceof</span> File)&#123;</span><br><span class="line">                System.out.println(<span class="string">"File "</span>+((File) f).filename);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f <span class="keyword">instanceof</span> Folder)&#123;</span><br><span class="line">                Folder e = (Folder)f ;</span><br><span class="line">                System.out.println(<span class="string">"Folder "</span>+e.foldername);</span><br><span class="line">                e.scan();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="12-享元模式（Flyweight）"><a href="#12-享元模式（Flyweight）" class="headerlink" title="12.享元模式（Flyweight）"></a>12.享元模式（Flyweight）</h5><p>使用共享对象的方法，用来尽可能减少内存使用量以及分享资讯。通常使用工厂类辅助，例子中使用一个HashMap类进行辅助判断，数据池中是否已经有了目标实例，如果有，则直接返回，不需要多次创建重复实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">flywei</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> <span class="keyword">extends</span> <span class="title">flywei</span></span>&#123;</span><br><span class="line">    Object obj ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FlyweightFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Object,Flyweight&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightFactory</span><span class="params">()</span></span>&#123; data = <span class="keyword">new</span> HashMap&lt;&gt;();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( data.containsKey(object))&#123;</span><br><span class="line">            <span class="keyword">return</span> data.get(object);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight flyweight = <span class="keyword">new</span> Flyweight(object);</span><br><span class="line">            data.put(object,flyweight);</span><br><span class="line">            <span class="keyword">return</span> flyweight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/07/12/JAVA设计模式/" data-id="cjjird1bf0005mw74uu93hd0z" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DesignPattern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/02/DesignPattern/" class="article-date">
  <time datetime="2018-06-02T04:52:50.000Z" itemprop="datePublished">2018-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/02/DesignPattern/">DesignPattern</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h3><p>目的：改写已存在的类的某个方法或某些方法，装饰设计模式（包装模式）<br>1、编写一个类，实现与被包装类相同的接口。(具备相同行为)<br>2、定义一个被包装类类型的变量<br>3、定义构造方法，把被包装类的对象注入，给被包装类变量赋值。<br>4、对于不需要改写的方法，调用原有方法。<br>5、对于需要改写的方法，写自己的代码。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>装饰设计模式的变体<br>只需要前四步就可以了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/06/02/DesignPattern/" data-id="cjjird1bb0004mw74e6k4mayf" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-DateBaseKnows" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/22/DateBaseKnows/" class="article-date">
  <time datetime="2018-05-22T06:05:36.000Z" itemprop="datePublished">2018-05-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/22/DateBaseKnows/">DateBaseKnows</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务是指逻辑上的一组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功。<br>start transaction | begin 开启事务<br>Rollback 回滚事务<br>Commit 提交事务</p>
<h6 id="在提交之前，只是在内存进行操作。只有commit才会操作数据库"><a href="#在提交之前，只是在内存进行操作。只有commit才会操作数据库" class="headerlink" title="在提交之前，只是在内存进行操作。只有commit才会操作数据库"></a>在提交之前，只是在内存进行操作。只有commit才会操作数据库</h6><h6 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DBUtils.getConnection();</span><br><span class="line"><span class="keyword">void</span> conn.setAutoCommit(<span class="keyword">false</span>);<span class="comment">//开启事务begin</span></span><br><span class="line"><span class="keyword">void</span> conn.commit();<span class="comment">//提交事务commit</span></span><br><span class="line"><span class="keyword">void</span> conn.rollback();<span class="comment">//回滚事务rollback();</span></span><br></pre></td></tr></table></figure>
<h4 id="事务的特征-ACID"><a href="#事务的特征-ACID" class="headerlink" title="事务的特征(ACID)"></a>事务的特征(ACID)</h4><p>原子性(Atomicity)：指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性(Consistency)：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。（即转账前后总金额不变）<br>隔离性(Isolation)：事务的隔离性是多用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。<br>持久性(Durability)：一个事务一旦被提交，它对数据库的改变是永久的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>赃读：指一个事务读取了另一个事务未提交的数据。<br>不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同。一个事务读取到了另一个事务提交后的数据。（update）<br>虚读（幻读）：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。(insert)</p>
<p>数据库通过设置事务的隔离级别防止以上情况的发生：</p>
<ul>
<li>1、READ UNCOMMITTED: 赃读、不可重复读、虚读都有可能发生。</li>
<li>2、READ COMMITTED: 避免赃读。不可重复读、虚读都有可能发生。（oracle默认的）</li>
<li>4、REPEATABLE READ:避免赃读、不可重复读。虚读有可能发生。（mysql默认）</li>
<li>8、SERIALIZABLE: 避免赃读、不可重复读、虚读。<br>（SERIALIZABLE实际开发根本用不到，一般用默认就可以了）<br>级别越高，性能越低，数据越安全<br>mysql中：<br>查看当前的事务隔离级别：SELECT @@TX_ISOLATION;<br>更改当前的事务隔离级别：SET TRANSACTION ISOLATION LEVEL 四个级别之一。（在事务开启前设置）<br>设置隔离级别必须在事务之前<h6 id="JDBC中控制事务的隔离级别"><a href="#JDBC中控制事务的隔离级别" class="headerlink" title="JDBC中控制事务的隔离级别"></a>JDBC中控制事务的隔离级别</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Connection接口有常量：</span></span><br><span class="line">    TRANSACTION_NONE = <span class="number">0</span></span><br><span class="line">    TRANSACTION_READ_UNCOMMITTED = <span class="number">1</span></span><br><span class="line">    TRANSACTION_READ_COMMITTED = <span class="number">2</span></span><br><span class="line">    TRANSACTION_READ_REPEATABLE_READ = <span class="number">4</span></span><br><span class="line">    TRANSACTION_READ_SERIALIZABLE = <span class="number">8</span></span><br><span class="line"><span class="comment">//可以在创建事务之前输入以下：</span></span><br><span class="line">conn.setTransactionIsolation(<span class="keyword">int</span>);<span class="comment">//参数就是上面的几个常量，或者直接写对应的数字</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p>
<h6 id="应用程序直接获取链接的缺点："><a href="#应用程序直接获取链接的缺点：" class="headerlink" title="应用程序直接获取链接的缺点："></a>应用程序直接获取链接的缺点：</h6><p>数据库创建链接通常需要消耗相对大的资源，创建时间也较长。而用户请求直接获取链接，用户访问几次就要创建几次，会造成极大的数据库资源浪费，并且极易造成数据库服务器内存溢出，宕机。</p>
<h6 id="连接池的目的："><a href="#连接池的目的：" class="headerlink" title="连接池的目的："></a>连接池的目的：</h6><p>解决建立数据库链接耗费的资源和时间的问题，提高性能。</p>
<h6 id="DBCP-DataBase-Connection-Pool"><a href="#DBCP-DataBase-Connection-Pool" class="headerlink" title="DBCP(DataBase Connection Pool)"></a>DBCP(DataBase Connection Pool)</h6><p>Apache推出的。<br>使用步骤：<br>添加jar包(commons-dbcp,commons-pool)-&gt;添加属性资源文件-&gt;编写数据源工具类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource ds = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			prop.load(DBCPUtil.class.getClassLoader().getResourceAsStream(<span class="string">"dbcpconfig.properties"</span>));<span class="comment">//根据当前类的classes路径，加载配置文件</span></span><br><span class="line">			ds = BasicDataSourceFactory.createDataSource(prop);<span class="comment">//基础数据源的工厂类，通过配置文件获得一个数据源(连接池)</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(<span class="string">"初始化异常，请检查配置文件"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ds.getConnection();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"服务器繁忙。"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h6><p>1、添加Jar包<br>2、编写配置文件<br>c3p0-config.xml或者用properties，放在classpath中，或者classes目录中<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方文档给出的：</span></span><br><span class="line">&lt;c3p0-config&gt;</span><br><span class="line">  &lt;<span class="keyword">default</span>-config&gt;</span><br><span class="line">    &lt;property name="automaticTestTable"&gt;con_test&lt;/property&gt;</span><br><span class="line">    &lt;property name="checkoutTimeout"&gt;30000&lt;/property&gt;</span><br><span class="line">    &lt;property name="idleConnectionTestPeriod"&gt;30&lt;/property&gt;</span><br><span class="line">    &lt;property name="initialPoolSize"&gt;10&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxIdleTime"&gt;30&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxPoolSize"&gt;100&lt;/property&gt;</span><br><span class="line">    &lt;property name="minPoolSize"&gt;10&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxStatements"&gt;200&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;user-overrides user=<span class="string">"test-user"</span>&gt;</span><br><span class="line">      &lt;property name="maxPoolSize"&gt;10&lt;/property&gt;</span><br><span class="line">      &lt;property name="minPoolSize"&gt;1&lt;/property&gt;</span><br><span class="line">      &lt;property name="maxStatements"&gt;0&lt;/property&gt;</span><br><span class="line">    &lt;/user-overrides&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/default-config&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- This app is massive! --&gt;</span><br><span class="line">  &lt;named-config name=<span class="string">"intergalactoApp"</span>&gt; </span><br><span class="line">    &lt;property name="acquireIncrement"&gt;50&lt;/property&gt;</span><br><span class="line">    &lt;property name="initialPoolSize"&gt;100&lt;/property&gt;</span><br><span class="line">    &lt;property name="minPoolSize"&gt;50&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxPoolSize"&gt;1000&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt;</span><br><span class="line">    &lt;property name="maxStatements"&gt;0&lt;/property&gt; </span><br><span class="line">    &lt;property name="maxStatementsPerConnection"&gt;5&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- he<span class="string">'s important, but there'</span>s only one of him --&gt;</span><br><span class="line">    &lt;user-overrides user=<span class="string">"master-of-the-universe"</span>&gt; </span><br><span class="line">      &lt;property name="acquireIncrement"&gt;1&lt;/property&gt;</span><br><span class="line">      &lt;property name="initialPoolSize"&gt;1&lt;/property&gt;</span><br><span class="line">      &lt;property name="minPoolSize"&gt;1&lt;/property&gt;</span><br><span class="line">      &lt;property name="maxPoolSize"&gt;5&lt;/property&gt;</span><br><span class="line">      &lt;property name="maxStatementsPerConnection"&gt;50&lt;/property&gt;</span><br><span class="line">    &lt;/user-overrides&gt;</span><br><span class="line">  &lt;/named-config&gt;</span><br><span class="line">&lt;/c3p0-config&gt;</span><br></pre></td></tr></table></figure></p>
<p>3、编写工具类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C3P0Util</span> </span>&#123;</span><br><span class="line">	<span class="comment">//得到一个数据源</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">	<span class="comment">//从数据源中得到一个连接对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"创建数据库连接失败"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><p>DBUtils是Java编程中的数据库操作使用工具，小巧简单实用。<br>DBUtils封装了对JDBC的操作，简化了JDBC操作。可以少写代码。<br>1.对于数据表的读操作，她刻意把结果转换成List，Array，Set等Java集合，便于程序员操作；<br>2.对于数据表的写操作，也变得很简单（只需写sql语句）<br>3.可以使用数据源，使用JNDI，数据库连接池等技术来优化性能–重用已经构建好的数据库连接对象</p>
<h5 id="DBUtils的三个核心对象"><a href="#DBUtils的三个核心对象" class="headerlink" title="DBUtils的三个核心对象"></a>DBUtils的三个核心对象</h5><p>QueryRunner类<br>ResultSetHandler类<br>DBUtils类</p>
<h6 id="QueryRunner类"><a href="#QueryRunner类" class="headerlink" title="QueryRunner类"></a>QueryRunner类</h6><p>主要有三个方法<br>query() 执行select<br>update()用于执行insert update delete<br>batch()批处理(批量处理数据)</p>
<h6 id="ResultSetHandler类"><a href="#ResultSetHandler类" class="headerlink" title="ResultSetHandler类"></a>ResultSetHandler类</h6><p>用于定义select操作后，怎样封装结果集</p>
<h6 id="DBUtils类"><a href="#DBUtils类" class="headerlink" title="DBUtils类"></a>DBUtils类</h6><p>定义了关闭资源与事务处理方法</p>
<h5 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h5><p>1.导入jar<br>2.创建QueryRunner对象<br>3.使用query方法执行select语句<br>4.使用ResultSetHandler封装结果集<br>5.使用DBUtils类释放资源</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/05/22/DateBaseKnows/" data-id="cjjird1au0000mw74b9z6lul2" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DateBase/">DateBase</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaWebMVC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/20/JavaWebMVC/" class="article-date">
  <time datetime="2018-05-20T14:31:33.000Z" itemprop="datePublished">2018-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/20/JavaWebMVC/">JavaWebMVC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里复习的大概就是软件工程这一节课上课的时候学的东西吧。。。（看视频）<br>C/S：客户端/服务器（胖客户端）<br>B/S：浏览器/服务器（瘦客户端）</p>
<h5 id="JavaBean："><a href="#JavaBean：" class="headerlink" title="JavaBean："></a>JavaBean：</h5><p>普通类（实体类bean），包含三种标准：一个无参构造，私有属性，共有的getter和setter方法</p>
<h4 id="1-Model1模式-已过时"><a href="#1-Model1模式-已过时" class="headerlink" title="1.Model1模式(已过时)"></a>1.Model1模式(已过时)</h4><p>JSP+JavaBean</p>
<h4 id="2-Model2模式-模拟MVC模式"><a href="#2-Model2模式-模拟MVC模式" class="headerlink" title="2.Model2模式(模拟MVC模式)"></a>2.Model2模式(模拟MVC模式)</h4><p>JSP+Servlet+JavaBean<br>MVC：开发模式<br>M：Model模型 JavaBean|四种作用域<br>V：view视图 JSP<br>C：Controller 控制器 Servlet<br>相应的，web分为三层：<br>表示层，业务层，数据访问层<br>包名：<br>domain(就是entity,bean)实体类<br>dao(接口)<br>dao.impl(dao实现类)<br>service(接口)<br>service.impl(实现类)<br>utils(工具类)<br>exception(自定义异常)<br>servlet(或者Web.servlet)(Web层)</p>
<h2 id="约定由于编码。列名，字段名，表单中的属性名一致"><a href="#约定由于编码。列名，字段名，表单中的属性名一致" class="headerlink" title="约定由于编码。列名，字段名，表单中的属性名一致"></a>约定由于编码。列名，字段名，表单中的属性名一致</h2><p>开发步骤：<br>一、开发框架技术选型<br>二、数据库表结构设计<br>三、UI界面设计和实现（前台）<br>四、后台业务代码实现、界面流转的编码实现（后台以及前后衔接）<br>五、完善、细化功能（界面细节、程序效率优化之类的）<br>六、集成测试</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/05/20/JavaWebMVC/" data-id="cjjird1bh0006mw7450j7mf95" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jsp复习阶段" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/jsp复习阶段/" class="article-date">
  <time datetime="2018-05-17T06:55:22.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/jsp复习阶段/">jsp复习阶段</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSP全程是JAVA Server Pages(java开发的服务器端页面)。JSP是Sun公司定义的一种用于动态开发Web资源的技术，JSP实质上就是Servlet(最后会编译成Servlet文件)。<br>JSP在MVC结构中属于View层。<br>Servlet适合编写Java逻辑代码（处理逻辑）。JSP适合编写动态内容，但不适合编写Java逻辑代码（显示数据）。</p>
<p>JSP页面第一次被访问的时候，实际上是进行了：<br>访问：index.jsp-转译-&gt;index_jsp.java-编译-&gt;index_jsp.class最终服务器执行并返回结果。（如果不是第一次访问，那么直接执行index_jsp.class，如果已经生成index_jsp.class，再次访问被修改过jsp文件，则会重新进行以上步骤。）</p>
<p>JSP继承于HttpJspBase，而HttpJspBase又继承于HttpServlet，并且重写了里面的方法（空的，抽象的，最终还是要在index_jsp.class中重写）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWrite out = response.getWrite();</span><br><span class="line">out.write();<span class="comment">//jsp用这个方法，将所有html标签和内容输出。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="JSP的基本语法"><a href="#JSP的基本语法" class="headerlink" title="JSP的基本语法"></a>JSP的基本语法</h3><h5 id="1-JSP模板元素："><a href="#1-JSP模板元素：" class="headerlink" title="1.JSP模板元素："></a>1.JSP模板元素：</h5><p>网页的静态内容，如html标签和文本。</p>
<h5 id="2-JSP的脚本"><a href="#2-JSP的脚本" class="headerlink" title="2.JSP的脚本"></a>2.JSP的脚本</h5><p>小脚本：&lt;% java代码 %&gt;<br>表达式：&lt;%= 变量名或者计算公式 %&gt;<br>声明：&lt;%! %&gt; ## 用于定义全局成员和静态代码块</p>
<h5 id="3-JSP注释"><a href="#3-JSP注释" class="headerlink" title="3.JSP注释"></a>3.JSP注释</h5><p>JSP注释:&lt;%– 注释内容 –%&gt; ## 在审查元素或者源代码中看不到的，安全<br>网页注释：<!-- 注释内容 --> ## 在审查元素或者源代码可以看到的，不安全</p>
<h5 id="4-3个指令"><a href="#4-3个指令" class="headerlink" title="4.3个指令"></a>4.3个指令</h5><p>并不直接产生认可可见的输出，而只是告诉引擎如何处理JSP页面中的其余部分<br>page,include,taglib<br>&lt;%@ 指令名称 属性1=”属性1” 属性2=”属性2”….. %&gt;<br>如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h6><p>用于预定义jsp页面的个各种属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line">    &lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Date,java.util.List"</span>%&gt;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">    &lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Date"</span>%&gt;</span><br><span class="line">    &lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.List"</span>%&gt;</span><br></pre></td></tr></table></figure></p>
<p>自动导好的有java.lang，javax.servlet.<em>，javax.servlet.http.</em>，javax.servlet.jsp.*;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性：</span><br><span class="line">    session:[<span class="keyword">true</span>|<span class="keyword">false</span>]是否生成Session对象，默认是<span class="keyword">true</span></span><br><span class="line">    pageEncoding:告诉服务器用什么语言翻译（也自动生成一句话告诉浏览器用什么编码解码）</span><br><span class="line">    isELIgnored:是否忽略EL表达式，默认值是<span class="keyword">false</span></span><br><span class="line">    errorPage:url   处理错误的页面</span><br><span class="line">    iserrorPage:[<span class="keyword">true</span>|<span class="keyword">false</span>]这是不是一个处理错误的页面</span><br><span class="line">    简单的写page只有两个必须属性，一个是<span class="keyword">import</span>，一个是pageEncoding</span><br></pre></td></tr></table></figure></p>
<h6 id="include"><a href="#include" class="headerlink" title="include"></a>include</h6><p>静态包含：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"url"</span>%&gt;</span><br></pre></td></tr></table></figure></p>
<p>转译前就包含了，所以最后会生成一个servlet文件，如果url指向的资源改变，就会重新生成servlet文件<br>动态包含：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page="url"&gt;&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure></p>
<p>在编译完后再包含，所以生成的是两个servlet文件，代码执行时才包含。<br>开发原则：能静态就不要动态</p>
<h6 id="taglib"><a href="#taglib" class="headerlink" title="taglib"></a>taglib</h6><p>在JSP页面中导入JSTL标签库，替换JSP中的java代码段<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">5</span>&gt;<span class="number">3</span>)&#123;</span><br><span class="line">    out.print(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">&lt;%@ taglib url=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span>%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=$&#123;<span class="number">5</span>&gt;<span class="number">3</span>&#125;&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="5-6个动作-实际开发中用不上"><a href="#5-6个动作-实际开发中用不上" class="headerlink" title="5.6个动作(实际开发中用不上)"></a>5.6个动作(实际开发中用不上)</h6><p><jsp:include>动态包含</jsp:include></p>
<p><jsp:forward>请求转发</jsp:forward></p>
<p><jsp:param>设置请求参数</jsp:param></p>
<p><jsp:usebean>创建一个对象</jsp:usebean></p>
<p><jsp:setproperty>给指定的对象赋值</jsp:setproperty></p>
<p><jsp:getproperty>取值指定对象的属性值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"/demo2"</span>).forward(request,response);</span><br><span class="line">&lt;%</span><br><span class="line">    request.setParameter(<span class="string">"name"</span>,<span class="string">"tom"</span>);</span><br><span class="line">%&gt;</span><br><span class="line">等价于</span><br><span class="line">&lt;jsp:forward page=<span class="string">"/demo2"</span>&gt;</span><br><span class="line">&lt;jsp:param name=<span class="string">"name"</span> value=<span class="string">"jerry"</span>&gt;</span><br><span class="line"><span class="comment">//###</span></span><br><span class="line"><span class="comment">//###</span></span><br><span class="line"><span class="comment">//###</span></span><br><span class="line"><span class="comment">//###</span></span><br><span class="line">&lt;jsp:useBean id="stu" class="com.study.entity.Student"&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;jsp:setProperty property=<span class="string">"name"</span> name=<span class="string">"stu"</span> value=<span class="string">"jerry"</span>&gt;</span><br><span class="line">&lt;jsp:getProperty property=<span class="string">"name"</span> name=<span class="string">"stu"</span>&gt;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">&lt;% </span><br><span class="line">    Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu.setName(<span class="string">"jerry"</span>);</span><br><span class="line">    out.print(stu.getName());</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></jsp:getproperty></p>
<h5 id="6-9个内置对象"><a href="#6-9个内置对象" class="headerlink" title="6.9个内置对象"></a>6.9个内置对象</h5><p>request(javax.servlet.http.HttpServletRequset)、response(javax.servlet.http.HttpServletResponse)、session((javax.servlet.http.HttpSession，由session=”boolean”确定)、application(javax.servlet.ServletContext)、exception(java.lang.Throwable，由isErrorPage=”boolean”确定)、page(java.lang.Object当前对象this，当前servlet实例)、config(javax.servlet.ServletConfig)、out(javax.servlet.jsp.JspWrite，字符输出，相当于printWrite)、pageContext(javax.servlet.jsp.PageContext)</p>
<p>pageContext、request、response、application四大域对象</p>
<h6 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,Object o)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">//下面是操纵其他域对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,Object o,<span class="keyword">int</span> Scope)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name,<span class="keyword">int</span> Scope)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name,<span class="keyword">int</span> Scope)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">findAttribute</span><span class="params">(String name)</span></span>;<span class="comment">//从page，request，session，application中依次查找，找到了就取值，结束查找</span></span><br><span class="line"><span class="comment">//Scope的值：</span></span><br><span class="line">PageContext.Page_Scope = <span class="number">1</span>;</span><br><span class="line">PageContext.Request_Scope = <span class="number">2</span>;</span><br><span class="line">PageContext.Session_Scope = <span class="number">3</span>;</span><br><span class="line">PageContext.Application_Scope = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>在普通类中可以通过pageContext获取其他的JSP隐式对象。<br>提供了简易方法：<br>pageContext.forward(“Demo2.jsp”);<br>pageContext.include(“Demo2.jsp”);</p>
<h5 id="7-四大域对象"><a href="#7-四大域对象" class="headerlink" title="7.四大域对象"></a>7.四大域对象</h5><p>PageContext：pageContext 存放数据当前页面有效，开发使用较少。<br>ServletRequest：request 存放的数据在一次请求（转发）内有效，开发使用非常多。<br>HttpSession：session，存放的数据在一次会话中有效，开发使用较多。存放登录信息时候。<br>ServletContext：application，存放数据在整个应用范围内有效，因为范围太大，尽量少用</p>
<h5 id="8-EL表达式"><a href="#8-EL表达式" class="headerlink" title="8.EL表达式"></a>8.EL表达式</h5><p>EL表达式可以：获取数据，运算，获取隐式对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$&#123;s&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">out.print(pageContext.findAttribute(<span class="string">"s"</span>))</span><br><span class="line"><span class="comment">//###</span></span><br><span class="line"><span class="comment">//###</span></span><br><span class="line"><span class="comment">//###</span></span><br><span class="line">$&#123;s.name&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">out.print(pageContext.findAttribute(<span class="string">"s"</span>).getName())</span><br><span class="line"><span class="comment">//这种语法叫属性导航</span></span><br></pre></td></tr></table></figure></p>
<p>EL表达式里，.运算符相当于调用了getter方法，.后面跟的是属性名字<br>[]运算符：.能做的[]能做，[]能做的.不一定能做。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//empty:判断null，空字符串和没有元素的集合都返回true</span></span><br><span class="line">$&#123; empty str&#125;<span class="comment">//判断str是否为空</span></span><br><span class="line"><span class="comment">//也可以结合三目运算符</span></span><br><span class="line">$&#123; empty str ? <span class="string">"空"</span>:<span class="string">"非空"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="EL表达式中的11个隐式对象："><a href="#EL表达式中的11个隐式对象：" class="headerlink" title="EL表达式中的11个隐式对象："></a>EL表达式中的11个隐式对象：</h6><p>pageContext(javax.servlet.jsp.PageContext)、pageScope(java.util.Map<string>)、requestScope(java.util.Map<string,object>)、sessionScope(java.util.Map<string,object>)、applicationScope(java.util.Map<string,object>)、param(java.util.Map<string,string>)、paramValues(java.util.Map<string,string[]>)、header(java.util.Map<string,string>，一个请求消息头)、headerValue(java.util.Map<string,string[]>，同名请求消息头)、initParam(java.util.Map<string,string>，Web.xml中的全局参数)、cookie(java.util.Map<string,cookie>).</string,cookie></string,string></string,string[]></string,string></string,string[]></string,string></string,object></string,object></string,object></string></p>
<h5 id="9-JSTL"><a href="#9-JSTL" class="headerlink" title="9.JSTL"></a>9.JSTL</h5><p>JSTL(JavaServerPage Standard Tag Library)JSP标准标签库<br>JSTL实现JSP中的逻辑处理(可以看作是对EL表达式的补充)。</p>
<h6 id="核心标签库"><a href="#核心标签库" class="headerlink" title="核心标签库"></a>核心标签库</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> prefix=<span class="string">"c"</span> %&gt;</span><br><span class="line"><span class="comment">//引用core库</span></span><br></pre></td></tr></table></figure>
<p>通用标签：set、out、remove<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置变量</span></span><br><span class="line">&lt;c:set var="num" value=$&#123;10+5&#125; scope="page"&gt;&lt;/c:set&gt;</span><br><span class="line"><span class="comment">//输出数据</span></span><br><span class="line">&lt;c:out value="$&#123;num&#125;"&gt;&lt;/c:out&gt;</span><br><span class="line"><span class="comment">//已出变更</span></span><br><span class="line">&lt;c:remove var="num"&gt;&lt;/c:remove&gt;</span><br><span class="line"><span class="comment">//移除后输出</span></span><br><span class="line">&lt;c:out value=$&#123;num&#125; defalut="aaa"&gt;&lt;/c:out&gt;</span><br></pre></td></tr></table></figure></p>
<p>条件标签<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var="num" value="5"&gt;&lt;/c:set&gt;</span><br><span class="line"><span class="comment">//if</span></span><br><span class="line">&lt;c:if test="$&#123;num&gt;3&#125;"&gt;结果为:true&lt;/c:if&gt;//没有else</span><br><span class="line">&lt;c:if test="$&#123;num&lt;=3&#125;"&gt;结果为:false&lt;/c:if&gt;//手动else</span><br><span class="line"><span class="comment">//switch</span></span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test="$&#123;num==1&#125;"&gt;&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;num==2&#125;"&gt;&lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test="$&#123;num==3&#125;"&gt;&lt;/c:when&gt;</span><br><span class="line">    <span class="comment">//default</span></span><br><span class="line">    &lt;c:otherwise&gt;&lt;/c:otherwise&gt;</span><br><span class="line"></span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure></p>
<p>迭代标签<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通循环</span></span><br><span class="line">&lt;c:forEach var=<span class="string">"i"</span> begin=<span class="string">"1"</span> end=<span class="string">"10"</span> step=<span class="string">"1"</span>&gt;</span><br><span class="line">&lt;/c:forEach&gt;//变量名为i，从1开始，10截止，步长为1</span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line">&lt;c:forEach items=<span class="string">""</span> var=<span class="string">""</span> varStatus=<span class="string">""</span>&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"><span class="comment">//items为传入对象，var为值，varStatus自带属性index从0开始，count从1开始，first，last，分别是int，int，boolean，boolean类型。</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/05/17/jsp复习阶段/" data-id="cjjird1cq0018mw74uto8y9rz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Servlet学习过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/13/Servlet学习过程/" class="article-date">
  <time datetime="2018-05-13T14:44:43.000Z" itemprop="datePublished">2018-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/13/Servlet学习过程/">Servlet学习过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里记录Servlet学习过程中遇到的一些觉得容易遗漏的知识点。<br>序列化-内存中的数据（全景图，类似于树图）转换成二进制写进磁盘。<br>反序列化-磁盘中的二进制数据读到内存。<br>JAVABean文件不可序列化的时候，要让它实现Serializable接口<br>序列化存盘的一种过程叫钝化（搁置）–在内存溢出或者服务器重启的时候发生(tomcat里的.ser文件)<br>在上面的问题解决后，.ser文件会被序列化后删除，这个过程叫活化（激活）</p>
<h3 id="Servlet做三件事"><a href="#Servlet做三件事" class="headerlink" title="Servlet做三件事"></a>Servlet做三件事</h3><p>获取表单数据，调用业务逻辑，分发转向。在MVC中，jsp和html为view，servlet为control，JAVABean为Model。</p>
<h4 id="1-重定向和转发的区别"><a href="#1-重定向和转发的区别" class="headerlink" title="1.重定向和转发的区别"></a>1.重定向和转发的区别</h4><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/定向映射或者地址"</span>);<span class="comment">//这个是封装好的方法，推荐</span></span><br><span class="line">或者</span><br><span class="line">response.setStatus(<span class="number">302</span>);<span class="comment">//告诉客户端重定向新的资源</span></span><br><span class="line">response.setHeader(<span class="string">"location"</span>, <span class="string">"/itheima/ServletReqResDemo8"</span>);</span><br></pre></td></tr></table></figure>
<p>上述是重定向是先将当前页面运行完，再执行下一页面，并且这一次请求的参数会丢失。(一次request)</p>
<h6 id="重定向response由客户端执行，客户端执行两次请求，地址栏会发生变化，不能传递数据，可以跳转到其他应用。"><a href="#重定向response由客户端执行，客户端执行两次请求，地址栏会发生变化，不能传递数据，可以跳转到其他应用。" class="headerlink" title="重定向response由客户端执行，客户端执行两次请求，地址栏会发生变化，不能传递数据，可以跳转到其他应用。"></a>重定向response由客户端执行，客户端执行两次请求，地址栏会发生变化，不能传递数据，可以跳转到其他应用。</h6><h5 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"/定向映射或者地址"</span>).forward(request,response);</span><br></pre></td></tr></table></figure>
<p>上述是请求转发是运行到请求转发的代码后，先运行下一页面，再回到这一页面接着运行，从代码可以看出，request和response还要转发到下一个地址，参数不会丢失。</p>
<h6 id="转发request由服务器执行，客户端只进行一次请求，地址栏不变，转发能够传递数据，不能跳转到其他应用。"><a href="#转发request由服务器执行，客户端只进行一次请求，地址栏不变，转发能够传递数据，不能跳转到其他应用。" class="headerlink" title="转发request由服务器执行，客户端只进行一次请求，地址栏不变，转发能够传递数据，不能跳转到其他应用。"></a>转发request由服务器执行，客户端只进行一次请求，地址栏不变，转发能够传递数据，不能跳转到其他应用。</h6><h4 id="2、response（服务器端对客户端的响应）的两个输出流"><a href="#2、response（服务器端对客户端的响应）的两个输出流" class="headerlink" title="2、response（服务器端对客户端的响应）的两个输出流"></a>2、response（服务器端对客户端的响应）的两个输出流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServletOutputStream <span class="title">getOuputStream</span><span class="params">()</span> <span class="comment">//输出二进制数据</span></span></span><br></pre></td></tr></table></figure>
<p>和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PrintWrite <span class="title">getWrite</span><span class="params">()</span>  <span class="comment">//得到文本数据</span></span></span><br></pre></td></tr></table></figure></p>
<p>两个方法相互排斥，在调用了一个方法后就不能调用另一个方法，如果同时调用了两个方法就会抛出异常。<br>Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎从response里面获取，Servlet引擎将这些数据当做响应消息正文，然后与各个响应状态行和响应头组合后输出到客户端。<br>Servlet的service方法结束后，Servlet引擎将检查getWrite或getOutputStream方法返回的输出流对象是否已经调用过close方法，如过没有Servlet引擎将调用close方法关闭该输出流对象。</p>
<h4 id="3-request"><a href="#3-request" class="headerlink" title="3.request"></a>3.request</h4><h5 id="请求包含"><a href="#请求包含" class="headerlink" title="请求包含"></a>请求包含</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> request.getRequestDispatcher(<span class="string">"/映射地址"</span>).include(request, response);</span><br></pre></td></tr></table></figure>
<p>这里请求包含和请求转发相似，唯一不同的是，请求转发是访问两个资源，而请求包含则是将两个资源合并一起访问。</p>
<h5 id="解决表单method是Get时传值乱码"><a href="#解决表单method是Get时传值乱码" class="headerlink" title="解决表单method是Get时传值乱码"></a>解决表单method是Get时传值乱码</h5><p>下面这串代码只能解决post方式的乱码问题，而遇到get乱码问题并不能解决。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="解决方式如下"><a href="#解决方式如下" class="headerlink" title="解决方式如下"></a>解决方式如下</h6><p>由于解决方式十分复杂，一个字段要进行一次下面的这个操作，所以表单method确保用post方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字段名：username</span><br><span class="line">String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">username = <span class="keyword">new</span> String(username.getBytes(<span class="string">"IOS-8895-1"</span>),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></p>
<h6 id="getContextPath"><a href="#getContextPath" class="headerlink" title="getContextPath"></a>getContextPath</h6><p>用于返回应用名</p>
<h6 id="setAttribute-getAttribute"><a href="#setAttribute-getAttribute" class="headerlink" title="setAttribute/getAttribute"></a>setAttribute/getAttribute</h6><p>保存/获取表单以外的元素</p>
<h6 id="getSession"><a href="#getSession" class="headerlink" title="getSession"></a>getSession</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession request.getSession()</span><br></pre></td></tr></table></figure>
<p>执行原理<br>1、获取名为JSESSIONID的cookie值<br>2、没有这个值，就创建一个HttpSession对象，分配第一个唯一的SessionID，并向客户端写一个JSESSIONID=sessionID的cookie。<br>3、如果有，那么获取Cookie值，从服务器中找到这个id对应的对象：<br>找到了继续服务<br>找不到进入第二步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpSession request.getSession(<span class="keyword">boolean</span> create)</span><br><span class="line"><span class="comment">//create=true时，功能与getSession一样。</span></span><br><span class="line"><span class="comment">//create=false时，与getSession相似，不同的是，如果找不到对应SessionID的值，就返回null（不创建新的Session，只是查询）</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-Session会话"><a href="#4-Session会话" class="headerlink" title="4.Session会话"></a>4.Session会话</h4><p>用户打开浏览器-访问服务器的web资源（单个或多个）-关闭浏览器（一个完整的会话过程，可以类比于打电话，只要两个人都不挂就继续，一方挂断就结束。）会话用于保持各个客户端自己的数据。<br>当浏览器第一次访问资源时候就创建Session，应用运行时，在存活时间内。到达存活时间或Session.invalidate()时候自动销毁。<br>Session是服务器端技术，利用这个技术，服务器在运行时可以为一个用户的浏览器创建一个其独享的HttpSession对象，由于Session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的Session中，当用户再去访问服务器中其他web资源时，其他web资源再从用户各自的session中取出数据为用户服务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Session常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,Object value)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function">HttpSession <span class="title">getId</span><span class="params">()</span></span>;<span class="comment">//返回Sessionid</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaxInactiveInterval</span><span class="params">(<span class="keyword">int</span> second)</span></span>;<span class="comment">//设置存活时间，默认30分钟</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span><span class="comment">//销毁session</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session的有效时间也可以在web.xml中设置</span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 设置session有效时间，单位是分钟 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Session依赖于Cookie，如果禁止Cookie则Session功能会同样禁用。（）<br>解决方案：<br>1、提示不要禁用Cookie（一般会提示网络连接超时）<br>2、URL重写，对网站的所有地址都重写<br><a href="http://url---&gt;httpL//url;JSESSIONID=sessionID" target="_blank" rel="noopener">http://url---&gt;httpL//url;JSESSIONID=sessionID</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.getSession();</span><br><span class="line">request.encodeURL(String url);</span><br><span class="line"><span class="comment">//看浏览器有没有发送Cookie的请求头，没有就重写URL，有不重写,且不能刷新</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-Cookie"><a href="#5-Cookie" class="headerlink" title="5.Cookie"></a>5.Cookie</h4><p>Cookies是客户端技术，程序把每一个用户的数据以Cookies的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.addCookie()</span><br><span class="line">request.getCookie()</span><br></pre></td></tr></table></figure></p>
<p>Cookie是键值对<name,value>（name不能唯一区分cookie，还要看path，value只能存英文。）<br>一个浏览器每个站点最多存放20个Cookie,一个浏览器最多存放300个Cookie，每个Cookie限制大小为4KB。默认的Cookie是Session级别的，即结束访问就删除。如果要存在磁盘上，则需要MaxAge设置值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cookie.setMaxAge(second);<span class="comment">//设置Cookie最大生存时间时间</span></span><br><span class="line"><span class="comment">//0则立即删除,-1则浏览器关闭时候删除</span></span><br><span class="line"><span class="keyword">int</span> cookie.getMaxAge();<span class="comment">//获取存在时间</span></span><br></pre></td></tr></table></figure></name,value></p>
<p>path默认值是Cookie对应的访问路径：url:<a href="http://localhost:8080/Study/Cookie/CookieDemo1则path为/Study/Cookie。如果另一个应用映射路径/Study/Cookie/aaa/CookieDemo2也能访问到这个Cookie，但如果映射路径是/Study/CookieDemo2则无法访问，这时候就要手动设置path值：" target="_blank" rel="noopener">http://localhost:8080/Study/Cookie/CookieDemo1则path为/Study/Cookie。如果另一个应用映射路径/Study/Cookie/aaa/CookieDemo2也能访问到这个Cookie，但如果映射路径是/Study/CookieDemo2则无法访问，这时候就要手动设置path值：</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cookie.setPath(<span class="string">"/Study"</span>);</span><br><span class="line"><span class="comment">//这时候只要是Study应用下的所有资源都能访问Cookie</span></span><br><span class="line">cookie.setPath(request.getContextPath());<span class="comment">//与上面的一样，但自动获取的不容易出错</span></span><br><span class="line">cookie.setPath(<span class="string">"/"</span>);<span class="comment">//"/"代表当前应用下的目录名称，和上面两个一样，但更简便，推荐</span></span><br></pre></td></tr></table></figure></p>
<h6 id="删除的时候最好设置路径，不然可能会删错"><a href="#删除的时候最好设置路径，不然可能会删错" class="headerlink" title="删除的时候最好设置路径，不然可能会删错"></a>删除的时候最好设置路径，不然可能会删错</h6><h6 id="Session是服务器端的技术，可以存储对象。Cookie是客户端技术，只能存储字符串。"><a href="#Session是服务器端的技术，可以存储对象。Cookie是客户端技术，只能存储字符串。" class="headerlink" title="Session是服务器端的技术，可以存储对象。Cookie是客户端技术，只能存储字符串。"></a>Session是服务器端的技术，可以存储对象。Cookie是客户端技术，只能存储字符串。</h6>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/05/13/Servlet学习过程/" data-id="cjjird1ch000ymw7432y83mn0" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MyEclipse无法查看servlet源码的问题解决" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/07/MyEclipse无法查看servlet源码的问题解决/" class="article-date">
  <time datetime="2018-05-07T05:09:09.000Z" itemprop="datePublished">2018-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/07/MyEclipse无法查看servlet源码的问题解决/">MyEclipse无法查看servlet源码的问题解决</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好久没有写博文啦~<br>中间忙了很久的毕设，学了一段时间的tensorflow和python<br>tensorflow因为是看官方文档和论文，所以笔记都在代码上，等毕业了就把源码分享上来（源码已经分享给我的小伙伴，小伙伴已经上传到他的私密库，因为我没有私密库。。。。。）<br>言归正传，昨天终于把毕设弄完了，今天想起来要摸一摸java了，不然本来就不好找工作，不复习可能更加难找。（没有工作经验的应届生全是泪~~~）结过，一早上都在整怎么看源码。。。。（不是效率低下，是坑太多了）<br>————–分隔符</p>
<p>今天，在复习servlet的时候，想看一看源码，第一是发现点开始没有源代码的界面。<a href="https://blog.csdn.net/m0_38039437/article/details/75082888" target="_blank" rel="noopener">一开始的解决方式</a><br>后来发现无论怎么导入都没有用，于是我尝试导入另一个版本的Tomcat，和src包。<br>结果很容易想到（不然怎么浪费一早上）<br>在折腾了好多次之后，发现，Myeclipse 2013 Professional的servlet源码的指向地址好像被锁定了（无论你添加的zip文件在那个地址，他最后显示的地址都是Myeclipse自带的包地址）<br>于是我找隔壁宿舍的同学要来了他的2016（因为之前老师给的2013没有出问题，而且2016也没多大变化，界面也稍微不习惯，就没有换，现在看来是个错误。。。）<br>中间还出现了双jdk的问题(1.7和1.8)以及32bit和64bit的问题（仍然是课上的jdk是32bit，但我不知道，因为我的电脑我都是装的64bit，只有这一个老师给的东西是32bit），然后卸载重装myeclipse 2016<br>接下来就是破解<br>问题来了！<br>在2016指定了src文件后并没有能改变结果。<br><img src="/2018/05/07/MyEclipse无法查看servlet源码的问题解决/../MyEclipse无法查看servlet源码的问题解决/zkhs.png" alt="Java EE 6.0 Generic"><br>没错，罪魁祸首就是他！原来是他的问题！用了myeclipse自带的JavaEE包！（包里有毒！）<br>于是我采用了<a href="https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.42/bin/apache-tomcat-7.0.42.zip" target="_blank" rel="noopener">自己所用的Tomcat</a>的api作为servlet的.class<img src="/2018/05/07/MyEclipse无法查看servlet源码的问题解决/../MyEclipse无法查看servlet源码的问题解决/ghyh.png" alt="更换以后"><br>紧接着，将<a href="https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.42/src/apache-tomcat-7.0.42-src.zip" target="_blank" rel="noopener">从官网上下载的对应的src文件</a>载入进去。<br>结果是，The file is not on classpath！！不是报错，是整个页面只有一个红色×号和这句话，以及一大片空白。<br><img src="/2018/05/07/MyEclipse无法查看servlet源码的问题解决/../MyEclipse无法查看servlet源码的问题解决/zsmq.jpg" alt=""><br>是你逼我的！内事不决，问，百，度！<br><a href="https://blog.csdn.net/yhzhaohy/article/details/52470732" target="_blank" rel="noopener">百度出来的博客</a><br>emmmmmmmu，还是有问题！<br>就在千钧一发之际！我的小伙伴叫我去吃饭了。<br>当然，这饭吃的，很不舒服，我的心里，有个问题，一直在萦绕：我是谁，我在哪，要干嘛。。（不对，是刚刚的问题到底在哪。。。）<br>一口橙汁下肚，灵机一动。（每个项目有个文件叫.settings！），橙汁都没来得及喝完就回宿舍开电脑。。。<br><img src="/2018/05/07/MyEclipse无法查看servlet源码的问题解决/../MyEclipse无法查看servlet源码的问题解决/zzda.png" alt="真像只有一个！"></p>
<p>Windows-Preferences-Java-Compiler-JDK Compliance<br>项目-Properties-Java Build Path<br>项目-settings-org.eclipse.wst.common.project.facet.core.xml<br>项目-Properties-Compiler-JDK Compliance<br>以上四个地方的JDK版本必须一样！（我的myeclipse的环境用的1.8，但是他自己还是引申出来了一个vm-1.8来供自己的虚拟机跑，虽然是同源的，但是对于配置文件来说也不一样！我才不会说这个坑我也踩了。。。。）</p>
<p>至此，<img src="/2018/05/07/MyEclipse无法查看servlet源码的问题解决/../MyEclipse无法查看servlet源码的问题解决/jg.png" alt="美滋滋">我要沉浸到学习的海洋里面了~</p>
<h6 id="真是一次有-keng-趣-duo-的问题解决过程啊"><a href="#真是一次有-keng-趣-duo-的问题解决过程啊" class="headerlink" title="真是一次有(keng)趣(duo)的问题解决过程啊."></a>真是一次有(keng)趣(duo)的问题解决过程啊.</h6><h3 id="奉劝大家不要用MyEclipse-2013-Professional-麻烦很多。IDEA我用过，但毕竟作为一个Myeclipse用的多的人来说，还是Myeclipse习惯一些（就是要破解）。还有就是，不用装双环境，新的JDK向下兼容！1-8的JDK有1-7的内容（当然现在1-9出好长一段时间了，新特性还是要了解一下的。）"><a href="#奉劝大家不要用MyEclipse-2013-Professional-麻烦很多。IDEA我用过，但毕竟作为一个Myeclipse用的多的人来说，还是Myeclipse习惯一些（就是要破解）。还有就是，不用装双环境，新的JDK向下兼容！1-8的JDK有1-7的内容（当然现在1-9出好长一段时间了，新特性还是要了解一下的。）" class="headerlink" title="奉劝大家不要用MyEclipse 2013 Professional,麻烦很多。IDEA我用过，但毕竟作为一个Myeclipse用的多的人来说，还是Myeclipse习惯一些（就是要破解）。还有就是，不用装双环境，新的JDK向下兼容！1.8的JDK有1.7的内容（当然现在1.9出好长一段时间了，新特性还是要了解一下的。）"></a>奉劝大家不要用MyEclipse 2013 Professional,麻烦很多。IDEA我用过，但毕竟作为一个Myeclipse用的多的人来说，还是Myeclipse习惯一些（就是要破解）。还有就是，不用装双环境，新的JDK向下兼容！1.8的JDK有1.7的内容（当然现在1.9出好长一段时间了，新特性还是要了解一下的。）</h3><p>看源码是一个好习惯，可以更加深入了解一个类。<br>for JathonKatu</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/05/07/MyEclipse无法查看servlet源码的问题解决/" data-id="cjjird1c2000jmw74i52hpfra" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-记一个V2EX上看到的问题18-03-21" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/21/记一个V2EX上看到的问题18-03-21/" class="article-date">
  <time datetime="2018-03-21T01:04:41.000Z" itemprop="datePublished">2018-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Exchange/">Exchange</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/21/记一个V2EX上看到的问题18-03-21/">记一个V2EX上看到的问题18-03-21</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在刷V2EX的时候看到了一个初学者可能会想不明白的问题（当然我自己也算是个初学者）<br>觉得，是一个不错的例子，所以这里列出来，供大家交流（其实是给自己记录一下思路）<br><a href="https://www.v2ex.com/t/200476" target="_blank" rel="noopener">原例子</a><br>这里，题目是：</p>
<h4 id="Python-列表操作-a-10-x-for-x-in-range-100-实际上发生了什么？后面的-90-个元素怎么处理的？"><a href="#Python-列表操作-a-10-x-for-x-in-range-100-实际上发生了什么？后面的-90-个元素怎么处理的？" class="headerlink" title="Python 列表操作 a[:10] = [x for x in range(100)] 实际上发生了什么？后面的 90 个元素怎么处理的？"></a>Python 列表操作 a[:10] = [x for x in range(100)] 实际上发生了什么？后面的 90 个元素怎么处理的？</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = list() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [chr(_) <span class="keyword">for</span> _ <span class="keyword">in</span> range(ord(<span class="string">'a'</span>), ord(<span class="string">'z'</span>)+<span class="number">1</span>)] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a </span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">10</span>] = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>)] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a </span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br></pre></td></tr></table></figure>
<p>这里，如果用过matlab的同学就很好理解了。<br>那么，我们来分析，他做了什么。：<br>    首先，创建一个a列表<br>    接着将[a~z]赋值给a<br>    输出a ## 可以看出此时的a是二十六个英文字母的列表<br>    这时候，a[:10] = [x for x in range(100)]，我们先分析右半部分，返回的是一个[0~99]的列表。那么困扰我们的问题就出在右半部分了。a[:10]是matlab和python中都出现过的切片(<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000" target="_blank" rel="noopener">这里插播廖雪峰的切片教程</a>)，可以看出，意思是对a列表的第一个元素到第十个元素的操作，这里是将前十个元素进行了删除，[然后再在列表的头部插入100个元素]|[或者是新建一个列表，将100个元素插入，然后再append进alist，最后将这个列表命名为a。]|[或者是将新列表copy进去的同时，a原有元素后移（链表思路）]<br>    这个问题，交给以后将python内存机制搞清楚的我吧，但大体思路逃不过这三个了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/03/21/记一个V2EX上看到的问题18-03-21/" data-id="cjjird1de001umw74ttgolf49" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux-unpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/18/linux-unpack/" class="article-date">
  <time datetime="2018-03-18T02:00:06.000Z" itemprop="datePublished">2018-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/18/linux-unpack/">linux-unpack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文介绍了linux下的压缩程式tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar这10种压缩文件进行操作<br>Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法：<br>tar命令的选项有很多(用man tar可以查看到)，但常用的就那么几个选项，下面来举例说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cf all.tar *.jpg</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包 ，-f指定包的文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure></p>
<p>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf all.tar</span><br></pre></td></tr></table></figure></p>
<p>这条命令是列出all.tar包中所有文件，-t是列出文件的意思<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure></p>
<p>这条命令是解出all.tar包中所有文件，-x是解开的意思<br>以上就是tar的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。</p>
<h4 id="1-tar调用"><a href="#1-tar调用" class="headerlink" title="1) tar调用"></a>1) tar调用</h4><p>gzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。与gzip 相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf all.tar.gz *.jpg</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个gzip压缩过的包，包名为all.tar.gz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将上面产生的包解开。</p>
<h4 id="2-tar调用bzip2"><a href="#2-tar调用bzip2" class="headerlink" title="2) tar调用bzip2"></a>2) tar调用bzip2</h4><p>bzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。<br>与bzip2相对的解压程序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cjf all.tar.bz2 *.jpg</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个bzip2压缩过的包，包名为all.tar.bz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将上面产生的包解开。</p>
<h4 id="3-tar调用compress"><a href="#3-tar调用compress" class="headerlink" title="3)tar调用compress"></a>3)tar调用compress</h4><p>compress也是一个压缩程序，但是好象使用compress的人不如gzip和bzip2的人多。.Z结尾的文件就是bzip2压缩的结果。与 compress相对的解压程序是uncompress。tar中使用-Z这个参数来调用compress。下面来举例说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cZf all.tar.Z *.jpg</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xZf all.tar.Z</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将上面产生的包解开<br>有了上面的知识，你应该可以解开多种压缩文件了，下面对于tar系列的压缩文件作一个小结：</p>
<h4 id="1-对于-tar结尾的文件"><a href="#1-对于-tar结尾的文件" class="headerlink" title="1)对于.tar结尾的文件"></a>1)对于.tar结尾的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure>
<h4 id="2-对于-gz结尾的文件"><a href="#2-对于-gz结尾的文件" class="headerlink" title="2)对于.gz结尾的文件"></a>2)对于.gz结尾的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip -d all.gz</span><br><span class="line"></span><br><span class="line">gunzip all.gz</span><br></pre></td></tr></table></figure>
<h4 id="3-对于-tgz或-tar-gz结尾的文件"><a href="#3-对于-tgz或-tar-gz结尾的文件" class="headerlink" title="3)对于.tgz或.tar.gz结尾的文件"></a>3)对于.tgz或.tar.gz结尾的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf all.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf all.tgz</span><br></pre></td></tr></table></figure>
<h4 id="4-对于-bz2结尾的文件"><a href="#4-对于-bz2结尾的文件" class="headerlink" title="4)对于.bz2结尾的文件"></a>4)对于.bz2结尾的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d all.bz2</span><br><span class="line"></span><br><span class="line">bunzip2 all.bz2</span><br></pre></td></tr></table></figure>
<h4 id="5-对于tar-bz2结尾的文件"><a href="#5-对于tar-bz2结尾的文件" class="headerlink" title="5)对于tar.bz2结尾的文件"></a>5)对于tar.bz2结尾的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjf all.tar.bz2</span><br></pre></td></tr></table></figure>
<h4 id="6-对于-Z结尾的文件"><a href="#6-对于-Z结尾的文件" class="headerlink" title="6)对于.Z结尾的文件"></a>6)对于.Z结尾的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompress all.Z</span><br></pre></td></tr></table></figure>
<h4 id="7-对于-tar-Z结尾的文件"><a href="#7-对于-tar-Z结尾的文件" class="headerlink" title="7)对于.tar.Z结尾的文件"></a>7)对于.tar.Z结尾的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xZf all.tar.z</span><br></pre></td></tr></table></figure>
<p>另外对于Window下的常见压缩文件.zip和.rar，Linux也有相应的方法来解压它们：</p>
<h4 id="1-对于-zip"><a href="#1-对于-zip" class="headerlink" title="1)对于.zip"></a>1)对于.zip</h4><p>linux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip all.zip *.jpg</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.jpg的文件压缩成一个zip包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip all.zip</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将all.zip中的所有文件解压出来</p>
<h4 id="2-对于-rar"><a href="#2-对于-rar" class="headerlink" title="2)对于.rar"></a>2)对于.rar</h4><p>要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从<a href="http://www.rarsoft.com/download.htm下载RARfor" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm下载RARfor</a> Linux 3.2.0，然后安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzpvf rarlinux-3.2.0.tar.gz </span><br><span class="line">cd rar </span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar a all *.jpg</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar 扩展名将自动附加到包名后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrar e all.rar</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将all.rar中的所有文件解压出来<br>到此为至，我们已经介绍过linux下的tar、gzip、gunzip、bzip2、bunzip2、compress 、 uncompress、 zip、unzip、rar、unrar等程式，你应该已经能够使用它们对.tar 、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar这10种压缩文<br>件进行解压了，以后应该不需要为下载了一个软件而不知道如何在Linux下解开而烦恼了。而且以上方法对于Unix也基本有效。<br>本文介绍了linux下的压缩程式tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar这10种压缩文件进行<br>操作。</p>
<p>以下补充<br>tar<br>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。<br>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出<br>下面的参数-f是必须的<br>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cf all.tar *.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 </span><br><span class="line">tar -rf all.tar *.gif</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -uf all.tar logo.gif</span><br></pre></td></tr></table></figure></p>
<p>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tf all.tar</span><br></pre></td></tr></table></figure></p>
<p>这条命令是列出all.tar包中所有文件，-t是列出文件的意思<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure></p>
<p>这条命令是解出all.tar包中所有文件，-x是解开的意思<br>压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg </span><br><span class="line">tar –czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz </span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 </span><br><span class="line">tar –cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z </span><br><span class="line">rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux </span><br><span class="line">zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</span><br></pre></td></tr></table></figure></p>
<p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf file.tar //解压 tar包 </span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz </span><br><span class="line">tar -xjvf file.tar.bz2 //解压 tar.bz2 </span><br><span class="line">tar –xZvf file.tar.Z //解压tar.Z </span><br><span class="line">unrar e file.rar //解压rar </span><br><span class="line">unzip file.zip //解压zip</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、<em>.tar 用 tar –xvf 解压<br>2、</em>.gz 用 gzip -d或者gunzip 解压<br>3、<em>.tar.gz和</em>.tgz 用 tar –xzf 解压<br>4、<em>.bz2 用 bzip2 -d或者用bunzip2 解压<br>5、</em>.tar.bz2用tar –xjf 解压<br>6、<em>.Z 用 uncompress 解压<br>7、</em>.tar.Z 用tar –xZf 解压<br>8、<em>.rar 用 unrar e解压<br>9、</em>.zip 用 unzip 解压</p>
<p>Linux下解压RAR软件下载和解压.zip和.rar文件<br>下载地址：<a href="http://www.rarsoft.com/download.htm（目前最新为RAR" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm（目前最新为RAR</a> 3.71 for Linux）<br>以最新的为准。<br>对于Window下的常见压缩文件.zip和.rar，Linux也有相应的方法来解压它们：<br>1:对于.zip<br>linux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，举例说明一下其用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip all.zip(这条命令是将all.zip中的所有文件解压出来)</span><br></pre></td></tr></table></figure></p>
<p>2:对于.rar<br>要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux不是免费的；可从<a href="http://www.rarsoft.com/download.htm下载RAR" target="_blank" rel="noopener">http://www.rarsoft.com/download.htm下载RAR</a> 3。60 for Linux ，然后安装其安装操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzpvf rarlinux-3.2.0.tar.gz</span><br><span class="line">cd rar</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar是解压程序。它们的参数选项很多，举例说明一下其用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar a all *.jpg</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar 扩展名将自动附加到包名后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrar e all.rar</span><br></pre></td></tr></table></figure></p>
<p>这条命令是将all.rar中的所有文件解压出来。<br>xxxx.tar.gz文件使用tar带zxvf参数，可以一次解压开。XXXX为文件名。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf xxxx.tar.gz</span><br><span class="line">gzip -d</span><br></pre></td></tr></table></figure></p>
<p>语 法：gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][文件…] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][目录]<br>补充说明：gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p>
<h6 id="参-数："><a href="#参-数：" class="headerlink" title="参 数："></a>参 数：</h6><p>-a或–ascii 使用ASCII文字模式。<br>-c或–stdout或–to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。<br>-d或–decompress或—-uncompress 解开压缩文件。<br>-f或–force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。<br>-h或–help 在线帮助。<br>-l或–list 列出压缩文件的相关信息。<br>-L或–license 显示版本与版权信息。<br>-n或–no-name 压缩文件时，不保存原来的文件名称及时间戳记。<br>-N或–name 压缩文件时，保存原来的文件名称及时间戳记。<br>-q或–quiet 不显示警告信息。<br>-r或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。<br>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 更改压缩字尾字符串。<br>-t或–test 测试压缩文件是否正确无误。<br>-v或–verbose 显示指令执行过程。<br>-V或–version 显示版本信息。<br>-&lt;压缩效率&gt; 压缩效率是一个介于1－9的数值，预设值为”6”，指定愈大的数值，压缩效率就会愈高。<br>–best 此参数的效果和指定”-9”参数相同。<br>–fast 此参数的效果和指定”-1”参数相同。</p>
<p>1、<em>.tar 用 tar –xvf 解压<br>2、</em>.gz 用 gzip -d或者gunzip 解压<br>3、<em>.tar.gz和</em>.tgz 用 tar –xzf 解压<br>4、<em>.bz2 用 bzip2 -d或者用bunzip2 解压<br>5、</em>.tar.bz2用tar –xjf 解压<br>6、<em>.Z 用 uncompress 解压<br>7、</em>.tar.Z 用tar –xZf 解压<br>8、<em>.rar 用 unrar e解压<br>9、</em>.zip 用 unzip 解压</p>
<p>Linux下*.tar.gz文件解压缩命令<br>1.压缩命令：<br>命令格式：tar -zcvf 压缩文件名.tar.gz 被压缩文件名<br>可先切换到当前目录下。压缩文件名和被压缩文件名都可加入路径。<br>2.解压缩命令：<br>命令格式：tar -zxvf 压缩文件名.tar.gz<br>解压缩后的文件只能放在当前的目录。<br>你可以使用 zip 命令同时处理多个文件和目录，方法是将它们逐一列出，并用空格间隔：<br>zip -r filename.zip file1 file2 file3 /usr/work/school<br>压缩单个目录命令zip -r filename.zip filename<br>上面的命令把 file1、file2、 file3、以及 /usr/work/school 目录的内容（假设这个目录存在）压缩起来，然后放入 filename.zip 文件中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jathonkatu.github.io/2018/03/18/linux-unpack/" data-id="cjjird1ct001bmw74n2trg6zm" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/13/Java面经/">Java面经</a>
          </li>
        
          <li>
            <a href="/2018/07/12/JAVA设计模式/">JAVA设计模式</a>
          </li>
        
          <li>
            <a href="/2018/06/02/DesignPattern/">DesignPattern</a>
          </li>
        
          <li>
            <a href="/2018/05/22/DateBaseKnows/">DateBaseKnows</a>
          </li>
        
          <li>
            <a href="/2018/05/20/JavaWebMVC/">JavaWebMVC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Exchange/">Exchange</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Study/">Study</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/毕设/">毕设</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS/">CS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DateBase/">DateBase</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali/">kali</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/入侵检测/">入侵检测</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 律_Ming<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>